

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Bachelorarbeit</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="None" href="../index.html"/>

<!-- Include all CSS and JS files, let's you use your own theme. -->

<link rel="stylesheet" type="text/css" href="../_static/custom.css" />
<script type="text/javascript">
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}

    $(document).ready(function() {
    	var im, imsrc;
    	$('img').each(function() {
    		im = $(this);
    		imsrc = im.attr('src');
    		imalt = im.attr('alt');
    		if (endsWith(imsrc, 'svg')) {
    			im.wrap($('<a>').attr({'href': imsrc, 'title': imalt}).addClass('svglink'));
    		}
    	});

    	$('a.svglink').colorbox({
    		'width': '95%',
    		'height': '95%',
    		'photo': true});
    });
</script>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html#document-rst/index" class="fa fa-home"> Bachelorarbeit</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/acknowledgements">Danksagung</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/dedication">Widmung</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/1_intro/index">1 Überleitung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/1_intro/index#das-allgemeine-problem">1.1 Das allgemeine Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/1_intro/index#das-konkrete-problem">1.2 Das konkrete Problem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/2_begriffe/index">2 Begriffsklärungen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/2_begriffe/index#allgemeine-fachbegriffe">2.1 Allgemeine Fachbegriffe</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/2_begriffe/index#kontextspezifische-fachbegriffe">2.2 Kontextspezifische Fachbegriffe</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/3_einleitung/index">3 Allgemeine Entwicklerhinweise</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/3_einleitung/index#zur-nuztung-von-libmunin">3.1 Zur Nuztung von <em>libmunin</em></a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/3_einleitung/index#zur-erweiterung-von-libmunin">3.2 Zur Erweiterung von <em>libmunin</em></a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/3_einleitung/index#vergleich-verschiedener-playlisten">3.3 Vergleich verschiedener Playlisten</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/3_einleitung/index#ressourcenverbrauch">3.4 Ressourcenverbrauch</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/4_graphops/index">4 Graphenoperationen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/4_graphops/index#id1">4.1 Graphenoperationen</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/4_graphops/index#graphentraversierung">4.2 Graphentraversierung</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/5_provider/index">5 Algorithmen bei Providern</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/5_provider/index#einleitung">5.1 Einleitung</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/5_provider/index#genrenormalisierung-und-vergleich-von-genres">5.2 Genrenormalisierung und Vergleich von Genres</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/5_provider/index#schlusselwortextraktion">5.3 Schlüsselwortextraktion</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/5_provider/index#moodbar">5.4 Moodbar</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/6_learning/index">6 Implizites Lernen vom Nutzer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/6_learning/index#generierung-von-regeln">6.1 Generierung von Regeln</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/6_learning/index#anwendung-von-regeln">6.2 Anwendung von Regeln</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/6_learning/index#lernerfolg">6.3 Lernerfolg</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/6_learning/index#explizites-lernen">6.4 Explizites Lernen</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/7_outro/index">7 Ausblick</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/7_outro/index#verbesserung-der-algorithmik">7.1 Verbesserung der Algorithmik</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/7_outro/index#erweiterungen">7.2 Erweiterungen</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/7_outro/index#fazit">7.3 Fazit</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix">Bilder des Song&ndash;Graphen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/appendix#allgemeine-hinweise">Allgemeine Hinweise</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/appendix#plotting-der-graphen">Plotting der Graphen</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix#bilder-des-genregraphen">Bilder des Genregraphen</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix#medien">Medien</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/zzz_bibliography">Bibliographie</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/zzz_bibliography#weblink-verzeichnis">Weblink Verzeichnis</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html#document-rst/index">Bachelorarbeit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html#document-rst/index">Docs</a> &raquo;</li>
      
    <li>Bachelorarbeit</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="libmunin-br-bachelorarbeit">
<span id="doc-title"></span><h1>libmunin: <br /> Bachelorarbeit<a class="headerlink" href="#libmunin-br-bachelorarbeit" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-rst/abstract"></span><div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
</div>
<p><strong>English:</strong></p>
<p>This paper shows the algorithms of the previously developed music recommendation
system <em>libmunin</em>. Apart from the construction of the internal graph data
structure, some selected, so called, providers and distance functions are
explained. Additionally, <em>libmunin's</em> mechanism for learning from the user in an
implicit or explicit way is shown in detail. Users of the library are supposed
to read this paper in order to maximize their understanding of <em>libmunin</em>. For
this purpose, some helpful tips for developing with and on <em>libmunin</em> are given
in the first chapters. At the end of the paper, some graphs and other
visualizations are shown, which were developed during the project.  In order to
understand the context, it is advisable to read the project report before
reading this paper. To be useful for interested developers, we reflect on the
shown topics in every chapter and list potential improvements.</p>
<p><strong>Deutsch:</strong></p>
<p>Diese Arbeit zeigt die Algorithmik hinter der vorgestellten
Musikemfehlungsbibliothek <em>libmunin</em>. Neben dem Aufbau des intern genutzten
Graphen, werden auch einige ausgewählte Provider und Distanzfunktionen erklärt.
Zusätzlich wird detailliert auf <em>libmunin's</em> Mechanismus zum implziten und
expliziten Lernen vom Nutzer eingegangen. Anwendungsentwickler sollten dieses
Papier lesen, um ihr Verständniss von <em>libmunin</em> zu vertiefen. Zu diesem Zwecke
werden anfangs einige hilfreiche Tipps für die Entwicklung von und mit
<em>libmunin</em> gegeben. Am Ende der Arbeit werden einige Graphen und
Visualisierungen gezeigt, die während der Arbeit an dem Projekt entstanden sind.
Es wird dringend empfohlen vor der Lektüre die Projektarbeit zu lesen um eine
grobe Übsersicht zu bekommen und den Kontext zu verstehen. Damit die Arbeit
nützlich für interessierte Entwickler ist, werden in jedem Kapitel die
vorgestellten Themen noch einmal reflektiert und potenzielle Verbesserungen
werden aufgezeigt.</p>
<span id="document-rst/acknowledgements"></span><div class="section" id="danksagung">
<h2>Danksagung<a class="headerlink" href="#danksagung" title="Permalink to this headline">¶</a></h2>
</div>
<p>Danke an folgende Personen und Dinge: Die Gattungen Felis silvestris und Aves,
Espressohersteller aller Länder, Herrn Prof. Dr. Jörg Scheidt (für die Zelle),
Herrn Prof. Dr.  Günter Köhler (für die Freiheit) und meiner Familie.</p>
<p>Ihr wisst schon warum.</p>
<span id="document-rst/dedication"></span><div class="section" id="widmung">
<h2>Widmung<a class="headerlink" href="#widmung" title="Permalink to this headline">¶</a></h2>
</div>
<p><em>Für meine Katzen.</em></p>
</div>
<div class="toctree-wrapper compound">
<span id="document-rst/abbrevs"></span><p><strong>Abkürzungsverzeichnis</strong></p>
<div class="figure align-center">
<center><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head align-top">Abkürzung</th>
<th class="head align-top">Bedeutung</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td class="align-top">API</td>
<td class="align-top"><em>Application Programming Interface</em></td>
</tr>
<tr class="row-odd"><td class="align-top">BPM</td>
<td class="align-top"><em>Beats per Minute</em></td>
</tr>
<tr class="row-even"><td class="align-top">FAQ</td>
<td class="align-top"><em>Frequently Asked Questions</em></td>
</tr>
</tbody>
</table>
</center></div><span id="document-rst/1_intro/index"></span><div class="section" id="uberleitung">
<h2>1 Überleitung<a class="headerlink" href="#uberleitung" title="Permalink to this headline">¶</a></h2>
<div class="section" id="das-allgemeine-problem">
<h3>1.1 Das allgemeine Problem<a class="headerlink" href="#das-allgemeine-problem" title="Permalink to this headline">¶</a></h3>
<p>Musik ist nur schwer vergleichbar. Fragt man mehrere Menschen wie
<em>ähnlich</em> ein Musikstück zu einem anderem ist, so erhält man genauso viele
Antworten wie man Fragen gestellt hat. Die Einschätzung von Musik ist eine sehr
subjektive Angelegenheit, die auch häufig zwischen Menschen Diskussionen
auslöst.  Stuft man die <em>Rolling Stones</em> als <em>Rock</em> ein? Oder doch eher als
<em>Pop?</em> Was zählt überhaupt noch als <em>Rock</em>? Gibt es eine Definition dafür?</p>
<p>Wenn man jetzt noch versucht einem Computer dem Begriff der <em>Musikähnlichkeit</em>
beizubringen wird es kompliziert. Dieser kann nur objektiv nach bestimmten
<em>Metriken</em> entscheiden. Diese Metriken zu definieren, muss dann wiederum die
Aufgabe eines Menschen sein &ndash;- also sind auch diese wiederum subjektiv, da sie
die <em>Vorlieben</em> des Autors widerspiegeln. Auch können diese Metriken nie für
alle Fälle funktionieren. Ein gutes Stück <em>,,Kaffeesatzleserei&quot;</em> lässt sich
leider nie ganz vermeiden.</p>
</div>
<div class="section" id="das-konkrete-problem">
<h3>1.2 Das konkrete Problem<a class="headerlink" href="#das-konkrete-problem" title="Permalink to this headline">¶</a></h3>
<p>So gesehen, ist <em>libmunin</em> in der <em>,,Standardeinstellung&quot;</em> ein
Musikempfehlungssystem, das genau auf einen Nutzer und dessen Vorlieben
zugeschnitten ist: Seinem Entwickler. Bibliotheksanwender können jedoch die
Bibliothek an ihre Präferenzen anpassen oder ihren Endnutzern eine Möglichkeit
geben, selbst Einstellungen vorzunehmen. So könnte man im praktischen Einsatz
die Gewichtung einzelner Attribute während der Laufzeit zu ändern.</p>
<p>Damit die Bibliotheksanwender diese Anpassungen vornehmen können, sollten sie
verstehen was intern vor sich geht. Genau darum soll es in dieser Arbeit gehen.
Es wird insbesondere auf die wichtigsten Provider und deren Funktionalität
eingegangen, wie diese sich auf die Distanzfunktionen auswirken und wie aus den
einzelnen Distanzen der komplette Graph aufgebaut wird. Zudem wird auf die
Lernfähigkeiten von <em>libmunin</em> eingegangen und die generierten Empfehlungen
werden näher betrachtet. Zu jedem vorgestellten Thema werden auch Überlegungen
angestellt, welche Verbesserungen in zukünftigen Versionen gemacht werden
können.</p>
</div>
</div>
<span id="document-rst/2_begriffe/index"></span><div class="section" id="begriffsklarungen">
<h2>2 Begriffsklärungen<a class="headerlink" href="#begriffsklarungen" title="Permalink to this headline">¶</a></h2>
<p>Wie in der Projektarbeit werden in den folgenden Kapiteln
einige Begriffe verwendet, die nicht allgemein verständlich sind oder in diesem
Kontext anders besetzt sind. Diese werden hier definiert. <br /> Die Begriffe
<a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a> und <a class="reference internal" href="rst/index.html#term-assoziationsregel"><em class="xref std std-term">Assoziationsregel</em></a> wurden im Vergleich zur
Projektarbeit um einige Details erweitert.</p>
<div class="section" id="allgemeine-fachbegriffe">
<h3>2.1 Allgemeine Fachbegriffe<a class="headerlink" href="#allgemeine-fachbegriffe" title="Permalink to this headline">¶</a></h3>
<dl class="glossary docutils">
<dt id="term-playlist">Playlist</dt>
<dd>Eine <em>Playlist,</em> zu deutsch <em>Wiedergabeliste</em>, ist eine Liste einzelner
Lieder, die nacheinander abgespielt werden. Die Zusammstellung einer
Playlist erfüllt oft einen gewissen Zweck. So stellt man für gewöhnlich
Lieder in einer <em>Playlist</em> zusammen, die eine gemeinsame Stimmung oder
eine andere Gemeinsamkeit <em>(,,Favorit&quot;)</em> besitzen.</dd>
<dt id="term-hashtabelle">Hashtabelle</dt>
<dd>Eine Hashtabelle ist eine Datenstruktur, die eine Abbildung von
eindeutigen Schlüsselwerten auf beliebige Werte möglich macht. Die
interessante Eigenschaft ist dabei der konstante Zeitaufwand beim
Nachschlagen eines Wertes durch den Schlüssel und dem effizienten
Hinzufügen neuer Schlüssel/Wert&ndash;Paare.</dd>
<dt id="term-breitensuche">Breitensuche</dt>
<dd>Verfahren um in definierter Weise einen Graphen zu traversieren. Dabei
wird ausgehend von einem Knoten zuerst jeder Nachbarknoten besucht. Erst
dann wird analog mit den Nachbarknoten verfahren. Bereits besuchte Knoten
werden markiert und nicht weiter verfolgt.</dd>
<dt id="term-iterator">Iterator</dt>
<dd>Ein Iterator ist ein <em>Versprechen</em> einen Wert genau dann zu berechnenl
wenn er gebraucht wird. Meistens werden Iteratoren dazu genutzt, um
Datenstrukturen zu traversieren. Jeder Aufruf des Iterators liefert dabei
den nächsten Wert oder signalisiert, dass keine neuen Werte mehr vorhanden
sind.</dd>
<dt id="term-tags">Tags</dt>
<dd>In Audiofiles können bei den meisten Formaten Metadaten abgelegt werden.
Dies wird oft genutzt um häufig gebrauchte Daten wie den <em>Künstler</em>,
<em>Album</em> und <em>Title</em>, aber auch komplexere Daten, wie das <em>Coverart</em>,
abzuspeichern. Tags können von geeigneten Tools wie Musicplayern
ausgelesen werden.</dd>
</dl>
</div>
<div class="section" id="kontextspezifische-fachbegriffe">
<h3>2.2 Kontextspezifische Fachbegriffe<a class="headerlink" href="#kontextspezifische-fachbegriffe" title="Permalink to this headline">¶</a></h3>
<dl class="glossary docutils">
<dt id="term-song">Song</dt>
<dd>Im Kontext von <em>libmunin</em> ist ein Song eine Menge von Attributen.  Jedem
<a class="reference internal" href="rst/index.html#term-attribut"><em class="xref std std-term">Attribut</em></a> ist, wie in einer Hashtabelle, genau ein Wert zugeordnet.
Beispielsweise haben alle Songs ein Attribut <tt class="docutils literal"><span class="pre">artist</span></tt>, aber jeder
einzelner Song kennt dafür einen bestimmten Wert.  Desweiteren wird für
jeden Song die Distanz zu einer Menge ähnlicher Songs gespeichert, sowie
einen Integer der als Identifier für diesen Song dient.</dd>
<dt id="term-seedsong">Seedsong</dt>
<dd>Ein <a class="reference internal" href="rst/index.html#term-song"><em class="xref std std-term">Song</em></a>, der als Basis für Empfehlungen ausgewählt wurde.</dd>
<dt id="term-session">Session</dt>
<dd>Eine <em>Session</em> ist eine Nutzung von <em>libmunin</em>, über einem bestimmten
Zeitraum. Zum Erstellen einer Session werden die Daten importiert,
analysiert und ein Graph wird daraus aufgebaut.
Wer die Bibliothek benutzt, wird die <em>Session</em> zudem als Eintrittspunkt
für die <em>API</em> benutzen.</dd>
<dt id="term-maske">Maske</dt>
<dd><p class="first">Die <a class="reference internal" href="rst/index.html#term-session"><em class="xref std std-term">Session</em></a> benötigt eine Beschreibung der Daten, die importiert
werden. So muss sich beispielsweise darauf geeinigt werden, <em>was</em> in einem
<a class="reference internal" href="rst/index.html#term-song"><em class="xref std std-term">Song</em></a> unter dem Schlüssel <tt class="docutils literal"><span class="pre">genre</span></tt> abgespeichert wird.</p>
<p class="last">In der <em>Maske</em> werden daher die einzelnen Attribute festgelegt, die ein
einzelner Song haben kann und wie diese anzusprechen sind. Zudem wird
pro Attribut ein <a class="reference internal" href="rst/index.html#term-provider"><em class="xref std std-term">Provider</em></a> und eine <a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a>
festgelegt, die bei der Verarbeitung dieses Wertes genutzt werden. Zudem
wird die Gewichtung des Attributes festgelegt. Manche Attribute sind
für die Ähnlichkeit zweier Songs entscheidender als andere.</p>
</dd>
<dt id="term-assoziationsregel">Assoziationsregel</dt>
<dd><p class="first">Eine Assoziationsregel verbindet zwei Mengen <em>A</em> und <em>B</em> von Songs mit
einer gewissen Wahrscheinlichkeit miteinander. Sie besagen, dass wenn eine
der beiden Mengen miteinander gehört wird, dann ist es <em>wahrscheinlich</em>,
dass auch die andere Menge daraufhin angehört wird.  Regeln werden aus dem
Verhalten des Nutzers abgeleitet. Dazu wird jedes Lied, das der Nutzer
anhört in einer <em>Historie</em> zwischengespeichert.
Um die generelle Anwendbarkeit der Regel zu beschreiben, wird für jede
Regel ein <em>Rating</em> berechnet.</p>
<p class="last"><em>Anmerkung:</em> Im Allgemeinen Gebrauch sind Assoziationsregeln nur in eine
Richtung definiert.  In <em>libmunin</em> sind die Regeln aus Gründen der
Einfachkeit allerdings <em>bidirektional.</em>  So gilt nicht nur, dass man
wahrscheinlich die Menge <em>B</em> hört, wenn man <em>A</em> gehört hat (<span class="math">\(A
\rightarrow B\)</span>), sondern auch umgekehrt (<span class="math">\(A \leftrightarrow B\)</span>).
Ein praktisches, natürlichsprachliches Beispiel hierfür: 60% der Basketballspieler
essen Cornflakes. Diese Regel besagt, dass der größte Teil der
Basketballspieler Cornflakes isst, aber nicht, dass die meisten
Cornflakes&ndash;Esser Basketballspieler sind. Da bei <em>libmunin</em> auf beiden
Seiten der Regel immer der gleiche Typ (ein oder mehrere Songs) steht und
die Beziehung immer <em>,,werden</em> miteinander <em>gehört&quot;</em> ist, ist hier eine
bidirektionale Assoziation möglich.</p>
</dd>
<dt id="term-attribut">Attribut</dt>
<dd>Ein Attribut ist ein <em>Schlüssel</em> in der Maske. Er repräsentiert
eine Vereinbarung mit dem Nutzer unter welchem Namen das Attribut in
Zukunft angesprochen wird. Zu jedem gesetzten Attribut gehört ein Wert,
andernfalls ein spezieller leerer Wert. Ein Song besteht aus einer
Menge dieser Paare.</dd>
<dt id="term-provider">Provider</dt>
<dd><p class="first">Ein <em>Provider</em> normalisiert einen Wert anhand verschiedener
Charakteristiken. Sie dienen zur vorgelagerten Verarbeitung von den Daten
die in <em>libmunin</em> geladen werden. Jeder <em>Provider</em> ist dabei durch die
Maske einem Attribut zugeordnet.</p>
<p class="last">Ihr Ziel ist für die <a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a> einfache und effizient
vergleichbare Werte zu liefern &ndash;- da die Distanzfunktion sehr
viel öfters aufgerufen wird als der <em>Provider</em>.</p>
</dd>
<dt id="term-distanz">Distanz</dt>
<dd>Eine Distanz beschreibt die Ähnlichkeit zweier Songs.
Eine Distanz von 0 bedeutet dabei eine maximale Ähnlichkeit (oder
minimale <em>Entfernung</em> zueinander), eine Distanz von 1 maximale
Unähnlichkeit (oder maximale <em>Entfernung</em>).
Die Distanz wird durch eine <a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a> berechnet.</dd>
<dt id="term-distanzfunktion">Distanzfunktion</dt>
<dd><p class="first">Eine Distanzfunktion ist im Kontext von <em>libmunin</em> eine Funktion, die zwei
Songs als Eingabe nimmt und die Distanz zwischen diesen berechnet. <br />
Dabei wird jedes Attribut betracht, welches in beiden Songs vorkommt. Für
diese wird von der Maske eine spezialisierte Distanzfunktion festgelegt,
die weiß wie diese zwei bestimmten Werte sinnvoll verglichen werden
können. Die so errechneten Werte werden, gemäß der Gewichtung in der
Maske, zu einem Wert verschmolzen. <br /> Fehlen Attribute in einen der
beiden Songs, wird für diese jeweils eine <em>,,Straf&quot;</em>&ndash;Distanz von
<span class="math">\(1\)</span> angenommen. Diese wird dann ebenfalls in die gewichtete
Oberdistanz eingerechnet.</p>
<p>Die folgenden Bedingungen müssen sowohl für die allgemeine
Distanzfunktion, als auch für die speziellen Distanzfunktionen gelten.
<span class="math">\(D\)</span> ist dabei die Menge aller Songs, <span class="math">\(d\)</span> eine Distanzfunktion.</p>
<ol class="arabic">
<li><p class="first"><em>Uniformität:</em></p>
<div class="math">
\[0 \leq d(i, j) \leq 1\forall i,j \in D\]</div>
<p><em>Aussage:</em> Die errechneten Werte müssen sich immer zwischen und
einschließlich <span class="math">\(0\)</span> und <span class="math">\(1\)</span> befinden. <em>libmunin</em> schneidet
unpassende Werte auf diesen Bereich zu.</p>
</li>
<li><p class="first"><em>Symmetrie:</em></p>
<div class="math">
\[d(i, j) = d(j, i) \forall i,j \in D\]</div>
</li>
</ol>
<blockquote>
<div><em>Aussage:</em> Die Reihenfolge, in der die Songs der Distanzfunktion
übergeben werden, darf keine Auswirkung auf das Ergebnis haben.
Diese Eigenschaft wird von <em>libmunin</em> nicht überprüft &ndash;- eine
Nichteinhaltung würde zu falschen Kanten im Graphen führen.</div></blockquote>
<ol class="arabic" start="3">
<li><p class="first"><em>Identität:</em></p>
<div class="math">
\[d(i, i) = 0 \forall i \in D\]</div>
<p><em>Aussage:</em> Wird zweimal der selbe Song übergeben, so muss die Distanz
immer <span class="math">\(0\)</span> betragen. Autoren von Distanzfunktionen sollten dies
testen.  Werte <span class="math">\(\neq 0\)</span> deuten erfahrungsgemäß auf schlechte
Distanzfunktionen hin.</p>
</li>
<li><p class="first"><em>Dreiecksungleichung:</em></p>
<div class="math">
\[d(i, j) \leq d(i, x) + d(x, j) \forall i,j,x \in D\]</div>
<p>In einer Dreiecksbeziehung zwischen drei Songs muss der direkte Weg
zwischen zwei Songs immer kürzer oder gleich lang wie der Umweg über
den dritten Song sein. Dies ist in  gezeigt.
Damit die Gewichtung der einzelnen Distanzen in die Oberdistanzen diese
Eigenschaft erfüllt wurde das Strafmaß eingeführt.</p>
</li>
</ol>
<div class="figure compound align-center" id="fig-trineqs">
<div style="width: 49%" class="subfigure align-center" id="fig-trineq">
<a class="reference internal image-reference" href="../../_images/trineq.svg"><img src="../../_images/trineq.svg" width="95%" /></a>
<p class="caption">Ohne Einhaltung der Dreiecksungleichung.</p>
</div>
<div style="width: 49%" class="subfigure align-center" id="fig-trineq-fixed">
<a class="reference internal image-reference" href="../../_images/trineq_fixed.svg"><img src="../../_images/trineq_fixed.svg" width="95%" /></a>
<p class="caption">Mit Einhaltung der Dreiecksungleichung.</p>
</div>
<p class="caption">Die Beziehung dreier Songs untereinander. Die Dreiecksungleichung
besagt, dass der direkte Weg von A nach B kürzer sein sollte als der
Umweg über C. Die einzelnen Attribute ,,a“ und ,,b“ sind gleich stark
gewichtet.  Wenn keine Straftwertung für leere Werte gegeben wird, so
sind die Umwege manchmal kürzer.</p>
<span class="target" id="fig-trineqs"></span></div></dd>
</dl>
</div>
</div>
<span id="document-rst/3_einleitung/index"></span><div class="section" id="allgemeine-entwicklerhinweise">
<h2>3 Allgemeine Entwicklerhinweise<a class="headerlink" href="#allgemeine-entwicklerhinweise" title="Permalink to this headline">¶</a></h2>
<p>In diesem Kapitel werden einleitend einige allgemeine Hinweise
gegeben, die man bei der Entwicklung mit und von <em>libmunin</em> beachten sollte.</p>
<div class="section" id="zur-nuztung-von-libmunin">
<h3>3.1 Zur Nuztung von <em>libmunin</em><a class="headerlink" href="#zur-nuztung-von-libmunin" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Die Qualität der Empfehlungen kann nur so gut sein, wie die Qualität der
Eingabedaten. Da in den meisten Fällen die Metadaten zu den einzelnen Liedern
aus den <a class="reference internal" href="rst/index.html#term-tags"><em class="xref std std-term">Tags</em></a> der Audiodateien kommen, empfiehlt es sich diese vorher
mit Musiktaggern einheitlich zu pflegen. Der Autor empfiehlt hierfür <em>Picard</em>
<a class="reference internal" href="rst/index.html#picard" id="id1">[Link&ndash;1]</a>, welches im Hintergrund auf <em>Musicbrainz</em> <a class="reference internal" href="rst/index.html#a3" id="id2">[Link&ndash;2]</a> zugreift.
Für schwerer zu besorgende Daten kann unter anderem auf libglyr, beets oder
dem eingebauten <tt class="docutils literal"><span class="pre">PlyrLyricsProvider</span></tt> und <tt class="docutils literal"><span class="pre">DiscogsGenreProvider</span></tt>
zurückgegriffen werden.</li>
<li>Welche Lieder man zu <em>libmunin's History</em> hinzufügt, sollte
abgewogen werden. Fügt man auch Lieder ein welche vom Nutzer einfach
übersprungen worden sind, so sind die erstellten Regeln nicht repräsentativ.
Es sollten nur Lieder hinzugefügt werden, welche auch mehr als <span class="math">\(50\%\)</span>
angehört worden sind.</li>
<li>Anwendungsentwickler sollten nach Möglichkeit eine eigene, für ihre Zwecke
konfigurierte <a class="reference internal" href="rst/index.html#term-session"><em class="xref std std-term">Session</em></a> <a class="reference internal" href="rst/index.html#term-maske"><em class="xref std std-term">Maske</em></a> verwenden. Zwar ist der Einsatz
der <tt class="docutils literal"><span class="pre">EasySession</span></tt> deutlich einfacher, doch ist diese mehr für den
<em>schnellen</em> Einsatz gedacht.  Zudem sollte es dem Endanwender möglich gemacht
werden, die Gewichtungen der einzelnen Attribute zu ändern.</li>
</ul>
</div>
<div class="section" id="zur-erweiterung-von-libmunin">
<h3>3.2 Zur Erweiterung von <em>libmunin</em><a class="headerlink" href="#zur-erweiterung-von-libmunin" title="Permalink to this headline">¶</a></h3>
<p>Oft es ist von Interesse neue Distanzfunktionen und <a class="reference internal" href="rst/index.html#term-provider"><em class="xref std std-term">Provider</em></a> für eigene
Zwecke zu schreiben. Im Folgenden werden einige Beispiele gegeben und
Stolperfallen aufgelistet.</p>
<div class="section" id="hinweise-zum-schreiben-von-distanzfunktionen">
<h4>3.2.1 Hinweise zum Schreiben von Distanzfunktionen<a class="headerlink" href="#hinweise-zum-schreiben-von-distanzfunktionen" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Wenn eine <a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a> eine Menge von Elementen vergleichen muss,
so besteht dieselbe oft aus einem <em>Fusionierungsverfahren</em> und einer weiteren
<em>Metrik</em>, die die einzelnen Elemente untereinander vergleicht.  Als Beispiel
kann man hier den Vergleich von zwei Mengen von Wörtern nennen.  Einzelne
Wörter kann man relativ einfach auf Ähnlichkeit untersuchen <a class="footnote-reference" href="#f1" id="id3"><sup>1</sup></a>.  Ein
simples Fusionierungsverfahren wäre hier jedes Wort aus der einen Menge mit
jedem Wort aus der anderen Menge zu vergleichen und den Durchschnitt der
Einzeldistanzen als Ergebnis anzunehmen. Ein anderes Fusionierungsverfahren
nimmt statt dem Durschschnitt die kleine gefundene <a class="reference internal" href="rst/index.html#term-distanz"><em class="xref std std-term">Distanz</em></a>. Hier gibt
es kein richtig oder falsch, je nach Einsatzzweck muss ein passendes Verfahren
gewählt werden.  Der dazugehörige Wikipedia&ndash;Artikel bietet, unter dem Punkt
Fusionierungsalgorithmen, einen guten Überblick über weitere Verfahren:
<a class="reference internal" href="rst/index.html#wiki-fusion" id="id4">[Link&ndash;3]</a>.</p>
</li>
<li><p class="first">Um konsistent zu bleiben sollten alle der zuvor genannten mathematischen
Eigenschaften einer <a class="reference internal" href="rst/index.html#term-distanzfunktion"><em class="xref std std-term">Distanzfunktion</em></a> eingehalten werden.</p>
</li>
<li><p class="first">Distanzfunktionen sollten schlechte Werte abstrafen und gute belohnen. Während
der Entwicklung hat sich gezeigt, dass simple Distanzfunktionen, die auch für
eigentlich gar nicht mehr ähnliche eine Distanz errechnen die <span class="math">\(\neq 1.0\)</span>
ist, zu qualitativ schlechten Verbindungen im Graphen führen. Man sollte daher
den Bereich, in denen man eine Distanz <span class="math">\(&lt; 1.0\)</span> vergibt, einschränken.</p>
<p>Im Folgendem Beispiel wird dies nicht getan und in der nachfolgenden
korrigierten Version verbessert:</p>
</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">munin.distance</span> <span class="kn">import</span> <span class="n">DistanceFunction</span>

<span class="c"># Eine Distanzfunktion, die beispielsweise ein Rating vergleicht.</span>
<span class="c"># Leite von der Distanzfunktions-Oberklasse ab:</span>
<span class="k">class</span> <span class="nc">MyDistanceFuntion</span><span class="p">(</span><span class="n">DistanceFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">do_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="c"># A und B sind, der Konsistenz halber, immer Tupel.</span>
        <span class="c"># Auch bei einzelnen Werten.</span>
        <span class="c"># Daher müssen wir diese erst ,,entpacken&quot;.</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Teile Differenz durch Maximum aus beiden:</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">munin.distance</span> <span class="kn">import</span> <span class="n">DistanceFunction</span>

<span class="k">class</span> <span class="nc">MyDistanceFuntion</span><span class="p">(</span><span class="n">DistanceFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">do_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
           <span class="k">return</span> <span class="mf">1.0</span>    <span class="c"># Zu unterschiedlich.</span>
        <span class="k">return</span> <span class="n">diff</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c"># Verteile auf [0, 0.25, 0.5, 0.75]</span>
</pre></div>
</div>
<ul>
<li><p class="first">Manchmal ist eine Eingrenzung des Bereichs nicht so einfach möglich, vor allem
wenn komplexere Daten im Spiel sind. Dann empfiehlt es sich die Verteilung der
Distanz auf Bereich zwischen <span class="math">\(0.0\)</span> und <span class="math">\(1.0\)</span> zu untersuchen.</p>
<p>Sollte sie sich beispielsweise gehäuft im Bereich zwischen <span class="math">\(0.3\)</span> und
<span class="math">\(0.7\)</span> bewegen, so ist es empfehlenswert diesen Bereich zu <em>dehnen</em>.  In
 werden mit der Funktion <span class="math">\(f(x) = -2\frac{2}{3}x^{3} +
4x^{2} - \frac{1}{3}x\)</span> Distanzen unter <span class="math">\(0.5\)</span> verbessert und darüber
verschlechtert.</p>
<div class="figure align-center" id="fig-stretch">
<a class="reference internal image-reference" href="../../_images/scale.svg"><img alt="Skalierungsfunktion der Distanzfunktion" src="../../_images/scale.svg" width="70%" /></a>
<p class="caption">Skalierungsfunktion der Distanzfunktion in Blau. Werte unter 0.5 werden
etwas weiter herabgesetzt, schlechtere Werte über 0.5 werden weiter erhöht.
Zur Referenz ist die Einheitsgerade in Grün gegeben.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="hinweise-zum-schreiben-von-neuen-providern">
<h4>3.2.2 Hinweise zum Schreiben von neuen Providern<a class="headerlink" href="#hinweise-zum-schreiben-von-neuen-providern" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Provider laufen im Gegensatz zu Distanzfunktionen nur einmal. Sie sind als
Präprozessor zu verstehen, der die vom Nutzer eingegebenen Daten auf möglichst
einfache und effiziente Vergleichbarkeit optimiert. Die Laufzeit, die er dafür
braucht ist daher im Vergleich zur Distanzfunktion vernachlässigbar.  Daher
sollte gut abgewogen werden wieviele Daten man dem Provider produzieren lässt.
Im Zweifelsfall empfiehlt es sich unnötiges wegzulassen.  - Ist zu erwarten,
dass stark redundante Daten eingepflegt werden, dann sollte die
Provider&ndash;interne Kompression genutzt werden. Ein typisches Beispiel dafür ist
der Künstler&ndash;Name. Dieser ist für sehr viele Songs gleich. Daher wäre eine
separate Speicherung desselben nicht sinnvoll. Intern bildet eine
bidirektionale <a class="reference internal" href="rst/index.html#term-hashtabelle"><em class="xref std std-term">Hashtabelle</em></a> (mittels <tt class="docutils literal"><span class="pre">bidict</span></tt> <a class="reference internal" href="rst/index.html#bidict" id="id5">[Link&ndash;4]</a>) gleiche
Werte auf einen Integer&ndash;Identifier ab.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">munin.provider</span> <span class="kn">import</span> <span class="n">Provider</span>

<span class="c"># Leite von der Provider-Oberklasse ab:</span>
<span class="k">class</span> <span class="nc">MyProvider</span><span class="p">(</span><span class="n">Provider</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Kompression anschalten, ansonsten muss auf nichts geachtet werden.</span>
        <span class="n">Provider</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># Funktion, die bei jeder einzelnen Eingabe aufgerufen wird.</span>
    <span class="k">def</span> <span class="nf">do_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">input_value</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c"># Tue irgendwas mit dem Input.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="vergleich-verschiedener-playlisten">
<span id="ref-playlist-compare"></span><h3>3.3 Vergleich verschiedener Playlisten<a class="headerlink" href="#vergleich-verschiedener-playlisten" title="Permalink to this headline">¶</a></h3>
<p>In Abbildung  wird eine Auflistung verschiedener, mit
unterschiedlichen Methoden erstellten  Playlists gegeben. Dies ist insofern
interessant, da die Struktur der von <em>libmunin</em> gegebenen Empfehlungen gewissen
Regeln unterliegt die man als Anwendungsentwickler kennen sollte. Zudem ist der
<em>subjektive</em> Vergleich mit anderen Systemen interessant.</p>
<p>Der ursprüngliche Plan hier auch eine von <tt class="docutils literal"><span class="pre">last.fm</span></tt> <a class="reference internal" href="rst/index.html#nt" id="id6">[Link&ndash;5]</a> erstellte
<a class="reference internal" href="rst/index.html#term-playlist"><em class="xref std std-term">Playlist</em></a> zu zeigen wurde eingestellt, da man dort die Empfehlungen nicht
auf die hier verwendete Testmusiksammlung aus 666 Songs einschränken konnte.
Stattdessen wurde die <em>Konkurrenz</em> von <em>libmunin</em> getestet: <em>Mirage</em>
<a class="reference internal" href="rst/index.html#schnitzer2007high" id="id7">[11]</a>. Da <em>Mirage</em> momentan nur als Plugin für Banshee
vorhanden ist und nicht als allgemeine Bibliothek verfügbar ist, wurde die
Testmusikdatenbank auch in Banshee importiert.</p>
<p>Die Testmusikdatenbank selbst besteht aus einigen ausgewählten Alben des Autors.
Viele allgemein gebräuchliche Gneres werden dabei abgedeckt, obwohl der
Schwerpunkt beim Genre <em>Rock</em> und <em>Metal</em> liegt.</p>
<p>Die einzelnen Playlists wurden auf jeweils 15 Songs begrenzt. Darin enthalten
ist an erster Stelle der willkürlich ausgewählte <a class="reference internal" href="rst/index.html#term-seedsong"><em class="xref std std-term">Seedsong</em></a>, der zum
Generieren der Playlist genutzt wurde (<em>Knorkator &ndash;- Böse</em>). Die zufällig
erstellte Playlist wurde als Referenz abgedruckt, damit man die dort fehlende
Struktur sehen kann.</p>
<p><strong>Auffälligkeiten:</strong></p>
<ul class="simple">
<li>Bei <em>libmunin</em> wiederholt sich der Künstler <em>Knorkator</em> alle 3&ndash;3 Stücke,
da der <em>Filter</em> entsprechend eingestellt ist. Daher ist eine Wiederholung des
Künstlers nur alle 3, und eine Wiederholung des Albums nur alle 5 Stücke
erlaubt. Bei Mirage scheint lediglich eine direkte Wiederholung des Künstlers
ausgeschlossen zu sein. Ansonsten wiederholen sich die Künstler
relativ beliebig. Die zufällige Playlist hat zwar auch keinerlei
Wiederholungen, aber entbehrt dafür auch jeder Struktur.</li>
<li><em>Mirage</em> leistet gute Arbeit dabei ähnlich klingende Stücke auszuwählen. Der
tempomäßig relativ langsame Seedsong (<em>Mirage</em> besitzt hier tatsächlich ein
änhliches Konzept) besitzt eine dunke Stimmung und harte E&ndash;Gitarren. Die von
<em>Mirage</em> vorgeschlagenen Songs sind hier tatsächlich sehr passend von der
Stimmung. Die von <em>libmunin</em> vorgeschlagenen Songs sind in Punkt
Audiodaten bei weitem nicht so übereinstimmend. Was aber auffällig ist, ist
dass größtenteils deutsche Titel (wie der Seedsong) vorgeschlagen werden. Auch
führt das <em>Parody</em> in der Genre&ndash;Beschreibung dazu, dass ebenfalls lustig oder
ironisch gemeinte Lieder vorgeschlagen werden. Zwar ist die Stimmung im
Seedsong düster, doch wird textlich ein Thema ironisch behandelt &ndash;- was
<em>Mirage</em> an den Audiodaten natürlich nicht erkennen kann.  Hier zeigt sich
<em>libmunin's</em> (momentaner) Fokus auf Metadaten.  Bei der zufälligen Playlists
passen zwar die Genres einigermaßen übereinander, doch liegt das eher an dem
sehr dehnbaren Begriff <em>Rock</em>, der bei
Discogs <a class="reference internal" href="rst/index.html#discogs" id="id8">[Link&ndash;6]</a> für sehr viele Lieder eingepflegt ist.</li>
<li>Der Kaltstart bei <em>Mirage</em> verlief in wenigen Minuten, während der Kaltstart
bei <em>libmunin</em> beim ersten mal für die 666 Songs sehr hohe 53 Minuten
benötigte, da für jedes Lied ein Liedtext sequentiell automatisch besorgt
worden ist. Siehe dazu auch Tabelle . Bei der Ausgabe der
Empfehlungen selber war bei allen Methoden keinerlei Verzögerung zu
beobachten.</li>
</ul>
</div>
<div class="section" id="ressourcenverbrauch">
<h3>3.4 Ressourcenverbrauch<a class="headerlink" href="#ressourcenverbrauch" title="Permalink to this headline">¶</a></h3>
<p>Damit Anwendungsentwickler die Aufwändigkeit einzelner Operation einschätzen
können, wird in Tabelle  eine kurze Übersicht über den
Ressourcenverbrauch einzelner Aspekte gegeben.
Die gemessenen Werte beziehen sich stets auf die Testumgebung mit 666 Songs.</p>
<div class="figure align-center" id="table-specs">
<center><table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Operation</strong></th>
<th class="head"><strong>Ressourcenverbrauch</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Speicherverbrauch</em></td>
<td>77.5 MB</td>
</tr>
<tr class="row-odd"><td><em>Speicherplatz der Session (gepackt)</em></td>
<td>0.9 MB</td>
</tr>
<tr class="row-even"><td><em>Speicherplatz der Session (ungepackt)</em></td>
<td>2.5 MB</td>
</tr>
<tr class="row-odd"><td><em>Zeit für den Kaltstart</em></td>
<td>53 Minuten <em>(63% Liedtextsuche + 37% Audioanalyse)</em></td>
</tr>
<tr class="row-even"><td> <tt class="docutils literal"><span class="pre">rebuild</span></tt></td>
<td>44 Sekunden</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">add</span></tt></td>
<td>87ms</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">insert</span></tt></td>
<td>164ms</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">remove</span></tt></td>
<td>54ms</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">modify</span></tt></td>
<td>219ms</td>
</tr>
</tbody>
</table>
<p class="caption">Auflistung des Ressourcenverbrauchs verschiedener Operationen.</p>
</center></div><p id="table-specs">Wie man sieht, sollte noch unbedingt Zeit investiert werden um den <em>Kaltstart</em>
zu beschleunigen. Auch die <tt class="docutils literal"><span class="pre">modify</span></tt>&ndash;Operation könnte durchaus noch optimiert
werden.</p>
<div class="figure align-center" id="table-playlists">
<center><table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="22%" />
<col width="23%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Nummer</strong></th>
<th class="head"><strong>Künstler</strong></th>
<th class="head"><strong>Titel</strong></th>
<th class="head"><strong>Genre</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>libmunin:</strong></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td> <em>01</em></td>
<td><em>Knorkator</em></td>
<td><em>Böse</em></td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td> <em>02</em></td>
<td>Letzte Instanz</td>
<td>Egotrip</td>
<td><em>Rock/Folk Rock, Goth Rock</em></td>
</tr>
<tr class="row-odd"><td><em>03</em></td>
<td>Nachtgeschrei</td>
<td>Lass mich raus</td>
<td><em>Rock/Folk Rock</em></td>
</tr>
<tr class="row-even"><td><em>04</em></td>
<td>Knorkator</td>
<td>Ick wer zun Schwein</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-odd"><td><em>05</em></td>
<td>Finntroll</td>
<td>Svart djup</td>
<td><em>Rock/Folk Metal, Black Metal</em></td>
</tr>
<tr class="row-even"><td><em>06</em></td>
<td>Heaven Shall Burn</td>
<td>Endzeit</td>
<td><em>Rock/Hardcore, Death Metal</em></td>
</tr>
<tr class="row-odd"><td><em>07</em></td>
<td>In Extremo</td>
<td>Liam</td>
<td><em>Rock/Medieval, Hard Rock</em></td>
</tr>
<tr class="row-even"><td><em>08</em></td>
<td>Knorkator</td>
<td>Konflikt</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-odd"><td><em>09</em></td>
<td>Letzte Instanz</td>
<td>Schlangentanz</td>
<td><em>Rock/Folk Rock, Goth Rock</em></td>
</tr>
<tr class="row-even"><td><em>10</em></td>
<td>Marc-Uwe Kling</td>
<td>Scheißverein</td>
<td><em>Folk/Parody</em></td>
</tr>
<tr class="row-odd"><td><em>11</em></td>
<td>Johnny Cash</td>
<td>Heart of Gold</td>
<td><em>Folk/Country, Rockabilly</em></td>
</tr>
<tr class="row-even"><td><em>12</em></td>
<td>Knorkator</td>
<td>Geh zu ihr</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-odd"><td><em>13</em></td>
<td>In Extremo</td>
<td>Erdbeermund</td>
<td><em>Rock/Medieval, Hard Rock</em></td>
</tr>
<tr class="row-even"><td><em>14</em></td>
<td>The Rolling Stones</td>
<td>Stealing My Heart</td>
<td><em>Rock/Pop Rock, Rock &amp; Roll</em></td>
</tr>
<tr class="row-odd"><td><em>15</em></td>
<td>Knorkator</td>
<td>Klartext</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td> <strong>Mirage:</strong></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td> <em>02</em></td>
<td>Knorkator</td>
<td>Ganz besond'rer Mann</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td><em>03</em></td>
<td>Coppelius</td>
<td>Operation</td>
<td><em>Rock/Classic, Medieval Metal</em></td>
</tr>
<tr class="row-odd"><td><em>04</em></td>
<td>Letzte Instanz</td>
<td>Salve Te</td>
<td><em>Rock/Folk Rock, Goth Rock</em></td>
</tr>
<tr class="row-even"><td><em>05</em></td>
<td>Apocalyptica</td>
<td>Fisheye</td>
<td><em>Rock/Symphonic Rock</em></td>
</tr>
<tr class="row-odd"><td><em>06</em></td>
<td>Coppelius</td>
<td>I Told You So!</td>
<td><em>Rock/Classic, Medieval Metal</em></td>
</tr>
<tr class="row-even"><td><em>07</em></td>
<td>Apocalyptica</td>
<td>Pray!</td>
<td><em>Rock/Symphonic Rock</em></td>
</tr>
<tr class="row-odd"><td><em>08</em></td>
<td>Knorkator</td>
<td>Klartext</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td><em>09</em></td>
<td>Devildriver</td>
<td>Black Soul Choir</td>
<td><em>Rock/Death Metal</em></td>
</tr>
<tr class="row-odd"><td><em>10</em></td>
<td>Finntroll</td>
<td>Fiskarens Fiende</td>
<td><em>Rock/Folk Metal, Black Metal</em></td>
</tr>
<tr class="row-even"><td><em>11</em></td>
<td>Devildriver</td>
<td>Swinging the Dead</td>
<td><em>Rock/Death Metal</em></td>
</tr>
<tr class="row-odd"><td><em>12</em></td>
<td>Knorkator</td>
<td>Es kotzt mich an</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td><em>13</em></td>
<td>Heaven Shall Burn</td>
<td>Forlorn Skies</td>
<td><em>Rock/Hardcore, Death Metal</em></td>
</tr>
<tr class="row-odd"><td><em>14</em></td>
<td>Knorkator</td>
<td>Hardcore</td>
<td><em>Rock/Parody, Heavy Metal</em></td>
</tr>
<tr class="row-even"><td><em>15</em></td>
<td>Rammstein</td>
<td>Roter Sand</td>
<td><em>Rock/Industrial, Hard Rock</em></td>
</tr>
<tr class="row-odd"><td> <strong>Zufall:</strong></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td> <em>02</em></td>
<td>Schandmaul</td>
<td>Drei Lieder</td>
<td><em>Rock/Folk Rock</em></td>
</tr>
<tr class="row-odd"><td><em>03</em></td>
<td>Tanzwut</td>
<td>Götterfunken</td>
<td><em>Electronic, Industrial</em></td>
</tr>
<tr class="row-even"><td><em>04</em></td>
<td>Finntroll</td>
<td>Suohengen sija</td>
<td><em>Ambient</em></td>
</tr>
<tr class="row-odd"><td><em>05</em></td>
<td>Biermösl Blosn</td>
<td>Anno Domini</td>
<td><em>Brass Band, Parody</em></td>
</tr>
<tr class="row-even"><td><em>06</em></td>
<td>Finntroll</td>
<td>Mordminnen</td>
<td><em>Rock/Folk Metal, Black Metal</em></td>
</tr>
<tr class="row-odd"><td><em>07</em></td>
<td>The Rolling Stones</td>
<td>Stealing My Heart</td>
<td><em>Rock/Pop Rock, Rock &amp; Roll</em></td>
</tr>
<tr class="row-even"><td><em>08</em></td>
<td>Die Ärzte</td>
<td>Ein Mann</td>
<td><em>Rock/Punk, Pop Rock</em></td>
</tr>
<tr class="row-odd"><td><em>09</em></td>
<td>Letzte Instanz</td>
<td>Regenbogen</td>
<td><em>Rock/Folk Rock, Goth Rock</em></td>
</tr>
<tr class="row-even"><td><em>10</em></td>
<td>Billy Talent</td>
<td>White Sparrows</td>
<td><em>Rock/Punk, Alternative Rock</em></td>
</tr>
<tr class="row-odd"><td><em>11</em></td>
<td>Letzte Instanz</td>
<td>Schlangentanz</td>
<td><em>Rock/Folk Rock, Goth Rock</em></td>
</tr>
<tr class="row-even"><td><em>12</em></td>
<td>Christopher Rhyne</td>
<td>Shadows of the Forest</td>
<td><em>Classical, Ambient</em></td>
</tr>
<tr class="row-odd"><td><em>13</em></td>
<td>The Beatles</td>
<td>Eight Days a Week</td>
<td><em>Pop/Rock &amp; Roll</em></td>
</tr>
<tr class="row-even"><td><em>14</em></td>
<td>Of Monsters and Men</td>
<td>From Finner</td>
<td><em>Pop/Folk, Indie Rock</em></td>
</tr>
<tr class="row-odd"><td><em>15</em></td>
<td>The Cranberries</td>
<td>Dreaming My Dreams</td>
<td><em>Rock/Alternative Rock</em></td>
</tr>
</tbody>
</table>
<p class="caption">Vergleich verschiedener, je 15 Lieder langen Playlisten.
Die Playlist im oberen Drittel wurde mittels des Seedsongs (01)
erstellt. Die im zweitem Drittel wurde mittels Mirage/Banshee
erstellt, die letzte wurde komplett zufällig generiert.</p>
</center></div><p class="rubric" id="table-playlists">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Etwa mit der Levenshtein&ndash;Distanzfunktion <a class="reference internal" href="rst/index.html#brill2000improved" id="id9">[4]</a> und
der Python&ndash;Bibliothek <tt class="docutils literal"><span class="pre">pyxDamerauLevenshtein</span></tt>
<a class="reference internal" href="rst/index.html#pyxdameraulevenshtein" id="id10">[Link&ndash;7]</a>.</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-rst/4_graphops/index"></span><div class="section" id="graphenoperationen">
<h2>4 Graphenoperationen<a class="headerlink" href="#graphenoperationen" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>4.1 Graphenoperationen<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Eine grobe Übersicht über die einzelnen Graphenoperationen und ihrer
Zuständigkeiten wurde bereits in der Projektarbeit gegeben. Im Folgenden
wird detailliert auf ihre Funktionsweise und Internas eingegangen.</p>
<div class="section" id="rebuild-aufbau-des-graphen">
<h4>4.1.1 rebuild: Aufbau des Graphen<a class="headerlink" href="#rebuild-aufbau-des-graphen" title="Permalink to this headline">¶</a></h4>
<p>Bevor irgendeine andere Operation ausgeführt werden kann, muss mittels der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation der Graph aufgebaut werden. Wie bereits in der
Projektarbeit erwähnt, kann der Graph aufgrund von einer Komplexität von
<span class="math">\(O(n2)\)</span> nicht einfach durch das Vergleichen aller Songs untereinander
erfolgend. Daher muss eine Lösung mit subquadratischen Aufwand gefunden werden.
Vorzugsweise eine, bei der Rechenaufwand gegen die Qualität der Approximation
abgewägt werden kann.  So kann der Nutzer entscheiden wie lange er <em>libmunin</em>
rechnen lassen will.</p>
<p>Der Ausgangszustand der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operationen ist eine Liste von Songs die
vom Nutzer bereitgestellt wird. Jeder Song darin soll nun so im Graphen
platziert werden, dass er im Bestfall die ähnlichsten Songs als Nachbarn hat.</p>
<p>Jeder Song speichert seine Nachbarn mit der dazugehörigen Distanz.  Soll ein
neuer Nachbar hinzugefügt werden, so wird geprüft ob die Distanz zu diesem neuen
Song besser ist, als die zum schlechtesten vorhandenen Nachbar.  Ist dies der
Fall, so wird die Entfernung zu diesem schlechtesten Nachbarn <em>in eine Richtung</em>
(die Gründe hierfür werden unter <a class="reference internal" href="rst/index.html#ref-distance-add">4.1.7</a> betrachtet) gekappt.
Als Ersatz wird zu dem neuen, besseren Song eine bidirektionale Verbindung
aufgebaut. Da die Verbindung zum schlechtesten Song nur unidirektional abgebaut
wird, ist die Anzahl der Nachbarn eines Songs nicht auf einen Maximum begrenzt,
da das Hinzufügen neuer Songs <em>,,Einbahnstraßen&quot;</em> hinterlässt.</p>
<p>Vielmehr handelt es sich dabei um einen Richtwert, um den sich die tatsächliche
Anzahl der Songs einpendeln wird. Momentan ist dieser Richtwert standardmäßig
auf <span class="math">\(15\)</span> gesetzt &ndash;- der durchschnittlichen Länge eines heutigen Albums
plus eins <a class="footnote-reference" href="#f1" id="id2"><sup>1</sup></a>. Dieser Wert hat sich nach einigen Tests als passabel erwiesen.
Bei zu niedrigen Werten verbinden sich die einzelnen Alben nur untereinander,
bei zu hohen entstehen zu viele qualitativ schlechte Verbindungen quer über den
ganzen Graphen.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Bestimmt an der persönlichen Sammlung des Autors. Bei 1590 einzelnen
Alben ist dieser Wert etwa <span class="math">\(14.142\)</span>.</td></tr>
</tbody>
</table>
<p>Wenn im folgenden vom <em>,,Berechnen der Distanz&quot;</em> gesprochen wird, so ist damit
auch das Hinzufügen der Distanz zwischen beiden Songs gemeint.</p>
<div class="figure compound align-center" id="fig-windows">
<div style="width: 50%" class="subfigure align-center" id="fig-window-sliding">
<a class="reference internal image-reference" href="../../_images/sliding_window.svg"><img alt="Schematische Darstellung des sliding_window" src="../../_images/sliding_window.svg" width="100%" /></a>
<p class="caption">Darstellung des sliding_window.</p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-centering">
<a class="reference internal image-reference" href="../../_images/centering_window.svg"><img alt="Schematische Darstellung des centering_window" src="../../_images/centering_window.svg" width="100%" /></a>
<p class="caption">Darstellung des centering_window.</p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-anti-centering">
<a class="reference internal image-reference" href="../../_images/anti_centering_window.svg"><img alt="Schematische Darstellung des anti_centering_window" src="../../_images/anti_centering_window.svg" width="100%" /></a>
<p class="caption">Darstellung des anti_centering_window.</p>
</div>
<p class="caption">Schematische Darstellungen der einzelnen Basisiterationen. Es werden jeweils
drei Iterationen in einem Bild dargestellt. Das Fenster in der ersten
Iteration ist dabei jeweils grün, in der zweiten gelb und in der letzten rot
dargegestellt. Die Zahlen repräsentieren einzelne Songs.</p>
</div><p id="fig-windows">Im Folgenden werden die drei Schritte der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation genauer
beleuchtet:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Für jeden Song wird nach willkürlich festgelegten
Prinzipien eine kleine Menge von möglicherweise ähnlicher Songs ausgewählt.
Diese Menge von Songs wird untereinander mit quadratischen Aufwand verglichen.
Diese Vorgehensweise wird mehrmals mit verschiedener Methoden wiederholt. Das
Ziel jeder dieser Iterationen ist es für einen Song zumindestens eine kleine
Anzahl von ähnlichen Songs zu finden. Basierend auf diesen wird in den
nächsten Schritten versucht, die Anzahl ähnlicher Songs zu vergrößern.</p>
<p>Momentan sind drei verschiedene Iterationsstrategien implementiert. Jede
basiert auf gewissen heuristischen Annahmen die über die Eingabemenge gemacht
wird:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">sliding_window:</span></tt> Schiebt ein <em>,,Fenster&quot;</em> über die Liste der Songs.
Alle Songs innerhalb des Fensters werden untereinander verglichen.  Die
Fenstergröße ist dabei konfigurierbar und ist standardmäßig auf 60
eingestellt, da sich diese Größe nach einigen Tests als guter Kompromiss
zwischen Qualität und Geschwindigkeit herausgestellt hat.  Bei jeder
Iteration wird das Fenster um ein Drittel der Fenstergröße
weitergeschoben.  Dadurch entsteht eine <em>,,Kette&quot;</em> von zusammenhängenden
Songs.</p>
<p>Die heuristische Annahme ist dabei, dass der Nutzer der Bibliothek seine
Datenbank meist nach Alben sortiert eingibt. Durch diese Sortierung finden
sich innerhalb eines Fensters oft Lieder des selben Albums &ndash;- diese  sind
oft sehr ähnlich.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">centering_window:</span></tt> Basiert ebenfalls auf einem Fenster. Im Gegensatz
zum obigen <tt class="docutils literal"><span class="pre">sliding_window</span></tt> besteht das Fenster allerdings aus zwei
Hälften, wobei die eine vom Anfang an startet und die andere Hälfte von
der Mitte aus bis zum Ende geschoben wird. Die Songs in beiden Hälften
werden analog zu oben untereinander verglichen. Auch hier überlappen sich
die einzelnen Hälften zu je zwei Drittel.</p>
<p>Die heuristische Annahme ist hier, dass in der bereits vorhandenen
<em>,,Kette&quot;</em> Querverbindungen hergestellt werden. Dies ist den nächsten
Schritten vorteilhaft um Iterationen einzusparen.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">anti_centering_window:</span></tt> Sehr ähnlich zum <tt class="docutils literal"><span class="pre">centering_window</span></tt>, statt
die zwei Hälfte aber von der Mitte aus bis zum Ende weiter zu schieben
wird diese vom Ende zur Mitte geschoben. So werden die beiden Hälften
solange weiter geschoben, bis sie sich in er Mitte treffen.</p>
<p>Auch hier sollen weitere Querverbindungen hergestellt werden.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Um den momentan sehr grob vernetzten Graphen benutzbar zu
machen, müssen einige Iterationen zur <em>,,Verfeinerung&quot;</em> durchgeführt werden.
Dabei wird über jeden Song im Graphen iteriert und dessen <em>indirekte Nachbarn</em>
(also die Nachbarn der direkten Nachbarsongs) werden mit dem aktuellen Song
verglichen. Kommen dabei Distanzen zustande, die niedriger sind als die der
aktuellen Nachbarn, wird der indirekte Nachbar zum direkten Nachbarn. Auf
diese Weise rücken ähnliche Songs immer weiter aufeinander zu.
Diese Vorgehensweise wird solange wiederholt bis nur noch eine geringe Anzahl
von Songs <em>,,bewegt&quot;</em> oder bis eine maximale Anzahl von Iterationen erreicht
ist. Die Begrenzung der Iterationen ist nötig, da es Fälle geben kann in denen
einzelne Songs immer wieder zwischen zwei gleich guten Zuständen hin- und
herspringen können.</p>
<p>Als zusätzliche Optimierung werden nicht alle indirekten Nachbarn betrachtet,
sondern nur diese, zu denen der Weg eine gewisse <em>Mindestdistanz</em> nicht
unterschreitet. Diese Mindestdistanz wird beim Start auf <span class="math">\(2.0\)</span> (da ja
die Distanz über zwei Kanten gemessen wird) gesetzt und während der folgenden
Iterationen immer weiter abgesenkt.</p>
<p>Die Gesetzmäßigkeit, nach der die Mindesdistanz immer weiter abgesenkt wird,
berechnet sich dabei aus dem arithmetischen Mittelwert, der bis dahin
berechneten Distanzen. Ist der Mittelwert hoch, so ist die Absenkung klein.</p>
</li>
<li><p class="first"><strong>Aufräumearbeiten:</strong> Nach dem Verfeinerungsschritt wird der Graph von
Einbahnstraßen durch einen <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt bereinigt und auf Konsistenz
geprüft.</p>
</li>
</ul>
<p>Wie bereits erwähnt gibt es eine <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt>&ndash;Operation, welche für
deutlich kleinere Mengen von Songs praktikabel einsetzbar ist. Die Algorithmik
ist hierbei bedeutend einfacher: Es wird einfach jeder Song mit jedem anderen
verglichen. Als Nachbarn erhält dabei jeder Song die Nachbarn, die global
betrachtet die kleinste Distanz zu diesem besitzen. Es handelt sich als um keine
Approximation wie beim herkömmlichen <tt class="docutils literal"><span class="pre">rebuild</span></tt>.</p>
<p>Auf die Betrachtung der Komplexität der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation wird an dieser
Stelle verzichtet. Keine der einzelnen Schritte erreicht dabei quadratische
Komplexität.  Die einzige Ausnahme ist dabei das Vergleichen der Songs
untereinander innerhalb eines Fensters, allerdings ist dabei  die Fenstergröße
stets auf ein verträgliches Limit begrenzt.</p>
<p>Unter Abb.  findet sich eine Gegenüberstellung von den
Aufrufen der Distanzfunktion, die bei <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt> und beim normalen
<tt class="docutils literal"><span class="pre">rebuild</span></tt> (mit und ohne <em>Verfeinerungsschritt</em>) nötig sind.</p>
<div class="figure align-center" id="fig-speed-cmp">
<a class="reference internal image-reference" href="../../_images/graph_speed.svg"><img alt="Vergleich der Distanzberechnungen für rebuild_stupid und rebuild" src="../../_images/graph_speed.svg" width="100%" /></a>
<p class="caption">Gegenüberstellung von verschiedenen Arten der rebuild&ndash;Operation. Auf der
Y&ndash;Achse ist logarithmisch die Anzahl der Distanzberechnungen aufgetragen,
auf der X&ndash;Achse die lineare Anazhl der Eingabesongs. Die blaue Kurve
repräsentiert dabei die Vergleiche die für rebuild_stupid notwendig sind.
Wie man sieht, übersteigen diese bis auf dem Gleichheitsbereich am Anfang die
anderen zwei Kurven deutlich.</p>
</div>
<p>Die einzelnen Schritte des Graphenaufbaus lassen sich in Abb.
, sowie bei den darauf folgenden Abbildungen,
nachvollziehen.</p>
</div>
<div class="section" id="fixing-umbauen-von-einbahnstraszen">
<h4>4.1.2 fixing: Umbauen von Einbahnstraßen<a class="headerlink" href="#fixing-umbauen-von-einbahnstraszen" title="Permalink to this headline">¶</a></h4>
<p>Diese Operation dient dem Entfernen von Einbahnstraßen innerhalb des Graphen.
Einbahnstraßen können wie bereits erwähnt beim Hinzufügen neuer Distanzen
entstehen.</p>
<p>Beim Entfernen wird folgendermaßen vorgegangen: Im ersten Schritt werden alle
unidirektionalen Kanten gefunden und abgespeichert. Für jede dieser Kanten wird
überprüft ob die Songs an beiden Enden den Richtwert für die Anzahl der Nachbarn
überschreitet. Sollte das nicht der Fall, so wird die Kante in eine
bidirektionale Kante umgebaut. Andernfalls wird die Kante gelöscht.</p>
<p>Dieses Vorgehen wurde gewählt weil es nach einigen Versuchen schwierig erschien,
den Graphen ohne Einbahnstraßen aufzubauen, ohne dass dieser zur Inselbildung
neigt. Durch den nachgelagerten <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt werden Songs die nur wenige
Nachbarn besitzen durch die vorher als zu schlecht bewerteten Kanten verbunden.
Als zusätzliche Konsistenzprüfung wird nach dem Bereinigen geprüft, ob alle
Verbindungen im Graphen bidirektional sind. Sollten unidirektionale Kanten
gefunden werden, so wird eine Warnung ausgegeben. Eine weiterführende
Fehlerbehandlung ist momentan noch nicht implementiert. Unidirektionale Kanten
können bei der Traversierung zu Ausnahmefehlern führen.</p>
</div>
<div class="section" id="add-hinzufugen-von-songs-vor-dem-rebuild">
<h4>4.1.3 add: Hinzufügen von Songs vor dem <tt class="docutils literal"><span class="pre">rebuild</span></tt><a class="headerlink" href="#add-hinzufugen-von-songs-vor-dem-rebuild" title="Permalink to this headline">¶</a></h4>
<p>Diese Operation benötigt als Argument eine Hashtabelle mit einer Abbildung von
Attributen auf Werte. Diese Werte werden dann, wie in der Projekarbeit
besprochen, durch verschiedene Provider normalisiert. Mit diesen normalisierten
Informationen wird dann eine neue Song&ndash;Instanz erzeugt, welcher beim Erzeugen
ein eindeutiger Identifier zugewiesen wird. Dieser Identifier dient dann als
Index in der internen Songliste.
Statt wie <tt class="docutils literal"><span class="pre">insert</span></tt> bereits Verbindungen zu anderen Songs herzustellen, fügt
diese Operation lediglich einen Song der internen Songliste hinzu. Die
eigentlichen Verbindungen werde in einem Rutsch von <tt class="docutils literal"><span class="pre">rebuild</span></tt> aufgebaut.</p>
<div class="figure compound align-center" id="fig-mini-graph-remove">
<span id="fig-mini-graph-remove-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-remove-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_remove_before.png"><img alt="../../_images/mini_graph_remove_before.png" src="../../_images/mini_graph_remove_before.png" style="width: 50%;" /></a>
<p class="caption">Vor der remove&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_remove_after.png"><img alt="../../_images/mini_graph_remove_after.png" src="../../_images/mini_graph_remove_after.png" style="width: 50%;" /></a>
<p class="caption">Nach der remove&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der remove&ndash;Operation.
Es wurde der mittlere Punkt in  gelöscht.
Daher haben sicht alle anderen Knoten einen anderen Nachbarn gesucht.</p>
<span class="target" id="fig-mini-graph-remove"></span></div><div class="figure compound align-center" id="fig-mini-graph-insert">
<span id="fig-mini-graph-insert-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-insert-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_insert_before.png"><img alt="../../_images/mini_graph_insert_before.png" src="../../_images/mini_graph_insert_before.png" style="width: 50%;" /></a>
<p class="caption">Vor der insert&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_insert_after.png"><img alt="../../_images/mini_graph_insert_after.png" src="../../_images/mini_graph_insert_after.png" style="width: 50%;" /></a>
<p class="caption">Nach der insert&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der insert&ndash;Operation. Es wurde
einfach ein weiterer Punkt in den Graphen eingefügt. Dieser hat sich mit
allen anderen verbunden.</p>
<span class="target" id="fig-mini-graph-insert"></span></div><div class="figure compound align-center" id="fig-mini-graph-modify">
<span id="fig-mini-graph-modify-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-modify-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_modify_before.png"><img alt="../../_images/mini_graph_modify_before.png" src="../../_images/mini_graph_modify_before.png" style="width: 60%;" /></a>
<p class="caption">Vor der modify&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_modify_after.png"><img alt="../../_images/mini_graph_modify_after.png" src="../../_images/mini_graph_modify_after.png" style="width: 60%;" /></a>
<p class="caption">Nach der modify&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der modify&ndash;Operation.
Es wurden jeweils die Mittelknoten der beiden Inseln mit einem höhren Rating
,,modifiziert”. Dadurch verbinden sich beide und verlieren dafür eine andere
Verbindung jeweils.</p>
<span class="target" id="fig-mini-graph-modify"></span></div></div>
<div class="section" id="remove-loschen-von-songs-zur-laufzeit">
<h4>4.1.4 remove: Löschen von Songs zur Laufzeit<a class="headerlink" href="#remove-loschen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h4>
<p>Um nach einer <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation einen Song auf dem Graphen zu löschen,
müssen alle Verbindungen zu diesem entfernt werden.  Um dabei eine Bildung von
Inseln (durch das Entfernen von Verbindungen) zu vermeiden, werden alle
ursprünglichen Nachbarn des zu entfernenden Songs untereinander verbunden. Dabei
wird folgendermaßen vorgegangen: Zuerst wird temporär für jeden Nachbarn den
Richtwert für die Anzahl der Nachbarn um eins erhöht. Im Anschluss wird die
Menge aller Nachbarn untereinander mit quadratischem Aufwand verglichen. Dadurch
bekommt jeder Nachbar, im besten Fall, eine neue Verbindung.  Abschließend werden
alle Verbindungen zum zu löschenden Song entfernt und der Richtwert wird wieder
um eins dekrementiert.</p>
<p>Da <em>libmunin</em> alle Songs in einer linearen List hält, muss auch dort der Song
gelöscht werden. Da der Index des Songs in der Liste gleich des <em>Identifiers</em>
des Songs ist, wird an dessen Stelle ein leerer Wert geschrieben. Damit dieser
möglichst bald wieder besetzt wird, wird der gelöschte <em>Identifier&ndash;Index</em> in
einer sogenannten <em>Revocation</em>&ndash;List gespeichert. Beim nächsten <tt class="docutils literal"><span class="pre">add</span></tt> oder
<tt class="docutils literal"><span class="pre">insert</span></tt> wird dieser <em>Identifier</em> dann wiederverwendet. Dieses Verfahren soll
eine Fragementierung der Song&ndash;Liste nach vielen <tt class="docutils literal"><span class="pre">remove</span></tt>&ndash;Operation
vermeiden.</p>
</div>
<div class="section" id="insert-hinzufugen-von-songs-zur-laufzeit">
<span id="ref-graphop-insert"></span><h4>4.1.5 insert: Hinzufügen von Songs zur Laufzeit<a class="headerlink" href="#insert-hinzufugen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h4>
<p>Diese Operation ist äquivalent zu <tt class="docutils literal"><span class="pre">add</span></tt>. Als Erweiterung fügt <tt class="docutils literal"><span class="pre">insert</span></tt>
allerdings den, durch <tt class="docutils literal"><span class="pre">add</span></tt> erzeugten Song auch in den Graphen ein und
verbindet ihn dort. Dazu muss zuerst ein <em>Punkt</em> gefunden werden an dem der Song
passend zu seinen Attributen <em>eingepasst</em> werden kann.</p>
<p>Diese <em>Einpassung</em> geschieht dabei folgendermaßen:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Es wird mit einer gewissen <em>Schrittweite</em> über die
Songliste iteriert. Dabei werden die Distanzen vom momentan aktuellen Song zum
einzufügenden Song berechnet. Dadurch wird der Song bereits mit einigen
anderen Songs verknüpft.  Die Größe der Schrittweite ist dabei abhängig von
der Länge der Songliste.  Je länger die Liste ist, desto größer ist die
Schrittweite.  Exakt ist sie dabei folgendermaßen definiert:</p>
<div class="math">
\[Schrittweite = \lceil\log_{10}songlist\_length\rceil\]</div>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Songs, zu denen im vorigen Schritt eine geringe Distanz
gefunden wurde, werden nun detaillierter betrachtet. Dazu wird die Distanz zu
den Nachbarn dieser <em>guten</em> Songs berechnet, unter der bekannten Annahme, dass
die indirekten Nachbar des einzufügenden Songs auch als potenzielle direkte
Nachbarn taugen.</p>
</li>
</ul>
<p>Als zusätzliche Beobachtung lässt sich feststellen, dass Songs die per
<tt class="docutils literal"><span class="pre">insert</span></tt> eingefügt werden deutlich <em>weitläufiger</em> verbunden sind als regulär
per <tt class="docutils literal"><span class="pre">add</span></tt> hinzugefügte. Diese Eigenschaft macht sich die in der Projektarbeit
gezeigte Demonanwedung zu Nutze: Ändert man das <em>Rating</em> eines Songs, so wird
der Song mitels <tt class="docutils literal"><span class="pre">remove</span></tt> gelöscht und mittels  <tt class="docutils literal"><span class="pre">insert</span></tt> anderswo wieder
eingefügt. Meist verbindet sich dabei der Song dann mit anderen ähnlich
bewerteten Songs. Diese bilden ein <em>zusätzliches Netz</em> über den Graphen, welches
weitläufrigere Sprünge ermöglicht.  Dadurch hat der Nutzer eine intuitive
Möglichkeit den Graphen seinen Vorstellungen nach umzubauen (Stichwort
<em>explizites Lernen</em>).</p>
</div>
<div class="section" id="modify-verandern-der-songattribute-zur-laufzeit">
<h4>4.1.6 modify: Verändern der Songattribute zur Laufzeit<a class="headerlink" href="#modify-verandern-der-songattribute-zur-laufzeit" title="Permalink to this headline">¶</a></h4>
<p>Diese Operation dient als Komfortfunktion. Sie ermöglicht das Verändern der
Attribute, beziehungsweise deren zugeordneten Werte, eines einzelnen Songs.
Würde man die Werte eines Songs manuell verändern, so müsste man alle Distanzen
zu diesem Song neu berechnen. Da dies wiederum Veränderungen im ganzen Graphen
hervorrufen könnte, wurden die Song&ndash;Instanzen unveränderbar <em>(,,Immutable&quot;)</em>
gemacht.</p>
<p>Die <tt class="docutils literal"><span class="pre">modify</span></tt>&ndash;Operation umgeht dieses Problem indem es den Song erst durch ein
<tt class="docutils literal"><span class="pre">remove</span></tt> entfernt und eine Kopie des ursprünglichen Songs macht, in der die
neuen Werte gesetzt werden. Dieser neue, noch unverbundene Song wird dann
mittels einer <tt class="docutils literal"><span class="pre">insert</span></tt>&ndash;Operation in den Graphen eingepasst.</p>
<p>Aufgrund dieser Abfolge unterschiedlicher Operation ist <tt class="docutils literal"><span class="pre">modify</span></tt> relativ
aufwendig. Es wird empfohlen diese Operation nur für einzelne Song jeweils
einzusetzen. Sollte ein bestimmtes Attribut in allen Songs geändert werden, so
ist eine <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation zu empfehlen.</p>
</div>
<div class="section" id="ablauf-beim-hinzufugen-einer-distanz">
<span id="ref-distance-add"></span><h4>4.1.7 Ablauf beim Hinzufügen einer Distanz<a class="headerlink" href="#ablauf-beim-hinzufugen-einer-distanz" title="Permalink to this headline">¶</a></h4>
<p>Wie bereits erwähnt speichert jeder Song eine Hashtabelle mit den jeweiligen
Songs, zu denen er eine Verbindung hält, als Schlüssel und der Distanz als Wert.
Um diese Hashtabelle zu füllen ist eine Funktion nötig, die sich nach näherer
Betrachtung als relativ schwierig zu implementieren gestaltete. Tatsächlich
wurden an die 2 Wochen mit unterschiedlichen Herangehensweisen verbracht.</p>
<p>Die Anzahl von Nachbarn pro Song sollte sich um einen gewissen <em>Richtwert</em>
einpendeln, den man konfigurieren kann. Daraus folgt, dass bei zu vielen
Nachbarn der <em>schlechteste Nachbarn</em> entfernt werden muss. Der anfängliche
Versuch die Verbindung zwischen den beiden Songs komplett zu löschen hatte aber
ein gewichtiges Problem: Die Inseln im Graphen, die jeweils ein Album
repräsentierten, haben sich nur untereinander verbunden. Verbindungen dazwischen
wurden immer wieder als der <em>schlechteste Nachbar</em> erkannt und entfernt. Daher
neigt der entstehende Graph stark zur Inselbildung und Bildung von starken
Clustern.</p>
<p>Die momentan Lösung ist dabei, dass der schlechteste Nachbar eine
unidirektionale Verbindung zu seinem ursprünglichen Partner aufrecht erhält. Die
Verbindung wird als nicht bidirektional gelöscht. Der Trick ist dabei: Bei der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation werden diese <em>Einbahnstraßen</em> immer noch von einer Seite
als Nachbarn erkannt. So kann insbesondere der <em>Verfeinerungsschritt</em> gut
zueinander passende Songs näher aneinander ziehen. Nach dem <tt class="docutils literal"><span class="pre">rebuild</span></tt> werden
übrig gebliebene Einbahnstraßen in normale Verbindungen umgebaut oder, falls
beide Enden der Verbindung bereits <em>,,voll&quot;</em> sind, gelöscht. So bleiben Songs,
zu denen kein passender Partner gefunden wurde, mit dem Rest des Graphen
verbunden.</p>
<p>Dieses Vorgehen bringt aber einige algorithmische Probleme mit sich: Das
Finden des schlechtesten Nachbarn würde jeweils linearen Aufwand zum Iterieren
über die Hashtabelle erfordern.  Zwar kann dann die schlechteste Distanz und der
dazugehörige Song zwischengespeichert werden, doch nach einigen Tests stellte
sich heraus, dass in den meisten Fällen ein neuer, schlechtester Song gesucht
werden muss. Das ist damit zu erklären, dass gegen Ende der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation tendenziell immer niedrigere Distanzen gefunden werden
&ndash;- womit immer wieder der schlechteste Song herausgelöscht werden muss.</p>
<p>Der momentane Ansatz speichert pro Song, neben der Hashtabelle mit den
Distanzen, auch einen Heap als <em>,,Lookup&ndash;Hilfe&quot;</em>.
In diesem werden, entgegen der natürlichen Unordnung in einer Hastabelle, die
zuletzt hinzugefügten Paare aus Distanzen und Songs partiell sortiert abgelegt.
Gemäß der Natur eines Heaps, ist dabei der Wurzelknoten immer das Element mit
der größten Distanz.  Ist es dann nötig eine neue, schlechteste Distanz zu
finden, so kann mit einem Aufwand von <span class="math">\(O(\log n)\)</span> das oberste Paar
herausgenommen werden.</p>
<p>Die <tt class="docutils literal"><span class="pre">distance_add()</span></tt> Funktion nimmt 3 Parameter. Die ersten zwei sind die
Songs (im Folgenden <em>A</em> und <em>B</em>), zwischen denen eine Verbindung hergestellt
werden soll. Der letzte ist die Distanz mit der diese Kante gewichtet wird.  Im
Folgenden ist der dazugehörige Python&ndash;Code in gekürzter, vereinfachter Form als
Referenz gegeben:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">distance_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Füge eine Kante zwischen zwei Songs mit einer Distanz hinzu.</span>

<span class="sd">    self, other: Die beiden Songs zwischen denen die Kante hergestellt werden soll.</span>
<span class="sd">    distance: Die Distanz dieser Kante.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c"># Selbe Referenz! Kann Endlosschleifen verursachen.</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">&lt;</span> <span class="n">distance</span> <span class="ow">and</span> <span class="n">song</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
        <span class="k">return</span>  <span class="c"># worst_cache ist die gespeicherte schlechteste Distanz oder None.</span>

    <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c"># Distanz zu diesem Song war bereits vorhanden und besser.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">return</span>  <span class="c">#  Da other bereits enthalten: Einfach updaten.</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>  <span class="c"># Finde den schlechtesten Nachbarn der noch valide ist.</span>
            <span class="n">worst_dist</span><span class="p">,</span> <span class="n">worst_song</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># Wurzelknoten</span>
            <span class="k">if</span> <span class="n">worst_song</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span>  <span class="c"># Probiere nächstes Element.</span>

        <span class="k">if</span> <span class="n">worst_dist</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="n">worst_dist</span>
            <span class="k">return</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">worst_song</span><span class="p">]</span>
        <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span>

    <span class="c"># Füge neue Kante in die Hashtabellen ein:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>

    <span class="c"># Speichere die Paare im Heap ab:</span>
    <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
    <span class="n">heappush</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># Hat sich möglicherweise geändert.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="graphentraversierung">
<h3>4.2 Graphentraversierung<a class="headerlink" href="#graphentraversierung" title="Permalink to this headline">¶</a></h3>
<p>Um nun tatsächlich Empfehlungen abzuleiten muss der Graph traversiert werden.
Je nach Art der Anfrage werden ein oder mehrere <em>Zentren</em> für eine
<a class="reference internal" href="rst/index.html#term-breitensuche"><em class="xref std std-term">Breitensuche</em></a>, sogenannte <em>Seedsongs</em>, ausgewählt. Bei einfachen Anfragen
in der Art <em>,,Gib 10 ähnliche zu Song X aus&quot;</em>, kann einfach der Song <em>X</em> als
Seedsong angenommen werden. Komplexere Anfragen wie <em>,,Gib 10 Songs die ein
Genre ähnlich Y haben aus&quot;</em> oder <em>,,Empfiehl mir 10 Songs basierend auf dem
Nutzerverhalten</em>&quot; erfordern das Auswählen mehrerer Seedsongs.</p>
<div class="section" id="empfehlungsiteratoren">
<h4>4.2.1 Empfehlungsiteratoren<a class="headerlink" href="#empfehlungsiteratoren" title="Permalink to this headline">¶</a></h4>
<p>In allen Fällen wird jedoch von einem Seedsong aus eine Breitensuche gestartet.
Statt diese Breitensuche <em>sofort</em> auszuführen, wird jeweils nur ein
<a class="reference internal" href="rst/index.html#term-iterator"><em class="xref std std-term">Iterator</em></a> bereitgestellt welcher immer nur eine Empfehlung generiert und
erst bei Zuruf die nächste Empfehlung dynamisch generiert. Dieses, aus der
funktionalen Programmierung bekannte Konzept, ist sehr nützlich beim Filtern der
generierten Empfehlungen, denn man weiß im Vornherein nicht wieviele
Empfehlungen ausgefiltert werden. So kann der Iterator einfach so lange bemüht
werden, bis die gewünschte Anzahl an Empfehlungen generiert worden sind.</p>
<p>Sollten mehrere Seedsongs vorhanden sein, so wird einfach für jedem ein
Breitensuche&ndash;Iterator erstellt. Dieser liefert erst den Seedsong, dann den
besten Nachbarn, dann nächst schlechteren Nachbarn und später geht es mit den
indirekten Nachbarn weiter.  Diese Liste von Iteratoren wird dann im
Round&ndash;Robin&ndash;Verfahren ineinander <em>verwebt</em>. Dabei wird je der erste Iterator
in der Liste angestoßen, dann immer wieder der nächste um wieder am Anfang zu
beginnen.</p>
<p>Der daraus entstehende Iterator wird dann dem Nutzer der Bibliothek
bereitgestellt. Wird ein Element aus diesem obersten Iterator genommen, so hat
das ein <em>,,Nachrutschen&quot;</em> von Iteratoren zur Folge. Diese Hierarchie von
Iteratoren ist in  gezeigt.</p>
<div class="figure align-center" id="fig-iterator">
<a class="reference internal image-reference" href="../../_images/iterator.svg"><img alt="Traversierung durch verschachtelte Iteratoren" src="../../_images/iterator.svg" width="80%" /></a>
<p class="caption">Traversierung durch verschachtelte Iteratoren. Zieht der Nutzer einen Song
aus dem obersten Iterator, so löst das eine ,,Lawine” von Iterationsschritten
aus. Dabei werden die einzelnen Schritte ,,fair” via einem
Round&ndash;Robin&ndash;Verfahren auf die einzelnen Seed&ndash;Songs aufgeteilt.</p>
</div>
</div>
<div class="section" id="anwendung-von-regeln">
<span id="ref-graphops-rules"></span><h4>4.2.2 Anwendung von Regeln<a class="headerlink" href="#anwendung-von-regeln" title="Permalink to this headline">¶</a></h4>
<p>Die Assoziationsregeln, die beim impliziten Lernen entstehen werden bei der
Traversierung als <em>,,Navigationshilfe&quot;</em> genutzt.
In  wird gezeigt, dass jedem Seedsong jeweils eine
Breitensuche und eine Menge von <em>Regeliteratoren</em> unterstellt sind.  <em>Libmunin</em>
bietet einen Mechanismus um alle Regeln abzufragen, die einen bestimmten Song
betreffen. Für jeden Song, der auf der <em>anderen</em> Seite der Regel vorkommt (also
die Seite, in der <em>nicht</em> der Seedsong vorhanden ist), wird ein
<em>Breitensucheniterator</em> erstellt.  <br />
Die einzelnen, den Regeln zugeordneten Iteratoren werden wieder im
Round&ndash;Robin&ndash;Verfahren abgewechselt. Der dadurch entstehende wird immer im
Wechsel mit dem <em>Breitensucheniterator</em>, der vom Seedsong ausgeht, abgefragt.
Daher besteht der Iterator, der aus einem Seedsong gebaut wird, wiederum aus
mehreren Unteriteratoren.</p>
</div>
<div class="section" id="filtern-der-iteratoren">
<h4>4.2.3 Filtern der Iteratoren<a class="headerlink" href="#filtern-der-iteratoren" title="Permalink to this headline">¶</a></h4>
<p>Da Alben im Graphen eng beieinander gepackt sind, werden ohne zusätzliches
Filtern natürlich auch Songs vom gleichen Album oder vom gleichen Künstler
geliefert. Dies ist für gewöhnlich nicht erwünscht &ndash;- man möchte ja neue Musik
entdecken, die nicht immer vom selben Künstler kommt. Der optionale
Filterschritt (oder <em>Sieving</em>&ndash;Schritt) dient dazu diese unerwünschten Songs
herauszufiltern.</p>
<p>Um dieses Ziel zu erfüllen, werden die <span class="math">\(20\)</span> letzten Empfehlungen
gespeichert, die von <em>libmunin</em> ausgegeben werden. War der Künstler einer zu
überprüfenden Empfehlung in den, beispielsweise, fünf letzten Empfehlungen
bereits vorhanden, so wird er ausgesiebt. Ähnlich wird mit dem Album
vorgegangen, nur hier ist die Schwelle standardmäßig bei drei. Die einzelnen
Schwellen können vom Nutzer konfiguriert werden. <br /> Auch das <em>Sieving</em> ist als
Iterator implementiert welcher Songs von einem Empfehlungsiterator nimmt, aber
nicht alle an den Nutzer weitergibt. Die vom Iterator übergangenen Songs werden
für den nächsten Iterationsschritt zwischengespeichert.</p>
</div>
</div>
</div>
<span id="document-rst/5_provider/index"></span><div class="section" id="algorithmen-bei-providern">
<h2>5 Algorithmen bei Providern<a class="headerlink" href="#algorithmen-bei-providern" title="Permalink to this headline">¶</a></h2>
<div class="section" id="einleitung">
<h3>5.1 Einleitung<a class="headerlink" href="#einleitung" title="Permalink to this headline">¶</a></h3>
<p>Im Folgenden werden einige ausgewählte Paare aus Providern und
Distanzfunktionen näher betrachtet. Nicht alle in der Projektarbeit
vorgestellten Provider werden erläutert, das würde auch den Umfang dieser Arbeit
übersteigen. Zudem sind die meisten Provider eher einfacher Natur &ndash;- die
Lektüre des jeweiligen Quelltextes sagt oft mehr als ein separater Text. Daher
werden im Folgenden nur die stark erklärungsbedürftigen Paare näher betrachtet.</p>
</div>
<div class="section" id="genrenormalisierung-und-vergleich-von-genres">
<h3>5.2 Genrenormalisierung und Vergleich von Genres<a class="headerlink" href="#genrenormalisierung-und-vergleich-von-genres" title="Permalink to this headline">¶</a></h3>
<p>Der Vergleich einzelner Genres ist eine schwierige Angelegenheit, da es,
zumindest im Bereich der Musik, keine standardisierte Einteilung von Genres
gibt. Oft sind sich nicht mal Menschen untereinander einig zu welchem Genre das
Album eines Künstlers zuzuteilen ist. Manchmal ist man sich nichtmal innerhalb
einer einzelnen Band einig. Ein Computer könnte höchstens erkennen wie
ähnlich zwei Genrebeschreibungen als Zeichenketten sind. Daher ist es nötig,
dass die einzelnen Genre&ndash;Eingaben anhand einer Sammlung von zusammengestellten
geläufigen Genres normalisiert werden.</p>
<div class="section" id="zusammenstellung-der-gernedatenbank">
<h4>5.2.1 Zusammenstellung der Gernedatenbank<a class="headerlink" href="#zusammenstellung-der-gernedatenbank" title="Permalink to this headline">¶</a></h4>
<p>Musikrichtungen können, wie in einem Baum, in Genres (<em>rock</em>, <em>pop</em>), Untergenres
(<em>country</em> rock, <em>japanese</em> pop), Unteruntergenres (<em>western</em> country rock)
&ndash;- und so weiter &ndash;- aufgeteilt werden. So lassen sich alle Genres und ihre
jeweiligen Untergenres als Baum darstellen. Als imaginären Wurzelknoten nimmt
man das allumfassende Genre <em>Music</em> an &ndash;- einfach weil sich <em>Music</em> hinter fast
jedes Genre schreiben lässt ohne den Sinn zu verändern.
Dieser Baum kann dann genutzt werden um beliebige Genres als <em>Pfad</em> durch den
Baum normalisiert abzubilden.</p>
<p>Die eigentliche Schwierigkeit besteht nun darin eine repräsentative Sammlung von
Genres in diesen Baum einzupflegen &ndash;- bei der hohen Zahl der existierenden Genres
kann man diese nur schwerlich manuell einpflegen.</p>
<p>Existierende Datenbanken wie, das sonst sehr vollständige, <em>MusicBrainz</em> liefern
laut ihren <em>FAQ</em> keine Genredaten:</p>
<blockquote class="epigraph">
<div><p><strong>Why Does Musicbrainz not support genre information?</strong></p>
<p><em>Because doing genres right is very hard.
We have thought about how to implement genres,
but we haven't completely settled on the right approach yet.</em></p>
<p class="attribution">&mdash;<a class="reference external" href="https://musicbrainz.org/doc/General_FAQ">https://musicbrainz.org/doc/General_FAQ</a> <a class="reference internal" href="rst/index.html#brainz-faq" id="id1">[Link&ndash;8]</a></p>
</div></blockquote>
<p>Also musste man sich nach anderen Quellen umschauen. Das vom
<tt class="docutils literal"><span class="pre">DiscogsGenreProvider</span></tt> verwendete <em>Discogs</em> bietet zwar relativ detaillierte
Informationen, teilt aber die Genres hierarchisch in zwei Ebenen auf, dem
<em>Genre</em> (<em>,,Rock&quot;</em>) und dem Untergenre (<em>,,Blackened Death Metal&quot;</em>) &ndash;- eine zu
grobe Einteilung.</p>
<p>Dafür fallen zwei andere Quellen ins Auge: <em>Wikipedia</em> &ndash;- fast jede Band
ist dort vertreten und eben auch mit detaillierter Genre Information &ndash;- sowie
<em>The Echonest</em> &ndash;- einem Unternehmen welches verschiedene Dienste rund um
Musikmetadaten anbietet, darunter auch eine Liste von den ihnen bekannten
Genres.</p>
<p>Mit diesen zwei Quellen sollte man einen repräsentativen Durchschnitt aller
Genres bekommen. Zuerst muss man allerdings an die Daten herankommen. Bei
<em>The Echonest</em> ist dies, nachdem man sich einen <em>API&ndash;Key</em> registriert hat
relativ einfach <a class="footnote-reference" href="#f1" id="id2"><sup>1</sup></a>:</p>
<div class="highlight-bash"><div class="highlight"><pre>http://developer.echonest.com/api/v4/artist/list_genres?api_key<span class="o">=</span>ZSIUEIVVZGJVJVWIS
</pre></div>
</div>
<p>Die Liste enthält, zum Zeitpunkt des Schreibens, <span class="math">\(898\)</span> konkrete Genres und
wird kontinuierlich vom Betreiber erweitert.</p>
<p>Die Suche bei Wikipedia gestaltet sich etwas schwieriger. Tatsächlich wurde
diese Quelle erst nachträglich nach einer Analyse des Quelltextes von <em>beets</em>
(ein Musikmetadatenmanager, siehe <a class="reference internal" href="rst/index.html#beets-source" id="id3">[Link&ndash;9]</a>) eingebaut. <em>Beets</em> hat
ebenfalls das Problem, das Genre zu normalisieren. Daher muss dort ein
entsprechender Mechanismus eingebaut sein. Dieser beruht, ähnlich wie hier,
ebenfalls auf einem Baum <a class="footnote-reference" href="#f2" id="id4"><sup>2</sup></a>. Um diese Quelle in <em>libmunin</em> zu nutzen wurde
lediglich der relevante Code von <em>beets</em> (MIT&ndash;Lizenz) nach <em>Python3</em> portiert
<a class="footnote-reference" href="#f3" id="id5"><sup>3</sup></a>.  Von der englischen Wikipedia werden folgende Seiten <em>gescraped,</em> also
der HTML&ndash;Seiteninhalt wird geparst, und die darin befindlichen Genres in eine
Datei geschrieben:</p>
<ul class="simple">
<li><em>List of popular music genres:</em> <a class="reference internal" href="rst/index.html#wiki-list-pop-music" id="id6">[Link&ndash;10]</a></li>
<li><em>List of styles of music: A&ndash;F, G&ndash;M, N&ndash;R, S&ndash;Z:</em> <a class="reference internal" href="rst/index.html#wiki-list-az-music" id="id7">[Link&ndash;11]</a></li>
</ul>
<p>Von Wikipedia kommen daher zusätzliche 1527 Einträge. Diese werden mit den
Einträgen von <em>The Echonest</em> verschmolzen. Nach einer Entfernung von Dubletten
ist die finale Genreliste 1876 Einträge lang.</p>
</div>
<div class="section" id="uberfuhrung-der-genreliste-in-einem-genrebaum">
<h4>5.2.2 Überführung der Genreliste in einem Genrebaum<a class="headerlink" href="#uberfuhrung-der-genreliste-in-einem-genrebaum" title="Permalink to this headline">¶</a></h4>
<div class="figure compound align-center" id="fig-tree">
<div style="width: 72%" class="subfigure align-center" id="fig-tree-input">
<a class="reference internal image-reference" href="../../_images/tree_input.svg"><img alt="Genreliste als Eingabe vor dem Prozessieren" src="../../_images/tree_input.svg" width="70%" /></a>
<p class="caption">Genreliste als Eingabe vor dem Prozessieren.</p>
</div>
<div style="width: 72%" class="subfigure align-center" id="fig-tree-init">
<a class="reference internal image-reference" href="../../_images/tree_init.svg"><img alt="Initialisierungsschritt" src="../../_images/tree_init.svg" width="100%" /></a>
<p class="caption">Initialisierungsschritt: Vergabe von Indizes und Zuordnung zum Wurzelknoten.</p>
</div>
<div style="width: 72%" class="subfigure align-center" id="fig-tree-first">
<a class="reference internal image-reference" href="../../_images/tree_first.svg"><img alt="Der Genrebaum nach der ersten Iteration" src="../../_images/tree_first.svg" width="100%" /></a>
<p class="caption">Der Genrebaum nach der ersten Iteration, ,,Swedish Alternative” wurde noch
nicht aufgebrochen.</p>
</div>
<div style="width: 72%" class="subfigure align-center" id="fig-tree-final">
<a class="reference internal image-reference" href="../../_images/tree_final.svg"><img alt="Der fertige Genrebaum als Ausgabe" src="../../_images/tree_final.svg" width="90%" /></a>
<p class="caption">Der nach zwei Iterationen fertige Genrebaum.</p>
</div>
<p class="caption">Der Baum wird aus der Eingabe unter  erzeugt indem erst
alle Genres dem Wurzelknoten ,,Music” unterstellt werden
(). Danach wird der Baum rekursiv (hier in zwei
Schritten,  und )
immer weiter vertieft.</p>
</div><p id="fig-tree">Nachdem eine Liste von Genres nun vorhanden, ist muss diese noch in einem Baum
wie in  gezeigt, überführt werden.
Begleitend werden dazu, die unter  gezeigte Genreliste als
Beispieleingabe. verwendet.</p>
<p>Der Baum sollte dabei folgende Kriterien erfüllen:</p>
<ul class="simple">
<li>Der Pfad von einem Blattknoten (<em>,,Swedish&quot;</em>) zum Wurzelknoten (<em>,,Music&quot;</em>)
sollte dabei das ursprüngliche Genre, mit dem optionalen Suffix <em>Music</em>
ergeben <em>(,,Swedish&ndash;Pop&ndash;Music&quot;)</em>.</li>
<li>Jeder Knoten erhält eine Index, der für jede Tiefenstufe von 0 wieder anfängt.
So hat der Knoten <em>music</em> immer den Index 0, bei der nächsten Ebene wird der
Index  nach alphabetischer Sortierung vergeben, <em>Pop</em> bekommt daher die 0,
<em>Reggae</em> die 1, <em>Rock</em> die 2 und so weiter.</li>
</ul>
<p>Das Umwandeln selbst geschieht folgendermaßen:</p>
<ul class="simple">
<li>Es wird manuell der Wurzelknoten <em>Music</em> angelegt.</li>
<li>Alle Genres in der Genreliste werden diesem Knoten als Kinder hinzugefügt.
(siehe Abb. )</li>
</ul>
<p>Nach dieser Vorarbeit wird rekusiv folgende Prozedur erledigt:</p>
<ol class="arabic simple">
<li>Gehe über alle Kinder des Wurzelknoten und breche dabei das <em>letzte
Element</em> des <em>Genres</em> ab (<em>Western Country Rock</em> wird zu <em>Western Country</em>
und <em>Rock</em>).</li>
<li>Der letzte Teil wird als Schlüssel in einer dem Knoten zugeordnete Hashmap
gespeichert, mit dem Rest als dazugehöriger Wert. Aufgrund der Natur von
Hashmaps, entledigt sich dies eventueller Dupletten.</li>
<li>Die Liste der Kinder des Wurzelknotens wird zu einer leeren Liste
zurückgesetzt.</li>
<li>Die Schlüssel der Hashmap werden als neue Kinder gesetzt, die dazugehörigen
Werte jeweils als deren Kinder. Dadurch vertieft sich der Baum.</li>
<li>Iteriere über die neuen Kinder, jedes Kind wird als neuer Wurzelknoten
angenommen und es wird von 1. an begonnen. Der Rekursionsstopp ist erreicht
wenn keine Aufteilung des Genres in letztes Element und Rest mehr möglich
ist.</li>
</ol>
<p>In unserem Beispiel ist der Baum bereits nach zwei Iterationen fertig
(). In  ist der Baum nach der ersten
Iteration zu sehen. <br />
Nach dem manuellen Aufbau werden noch einige halbautomatische Aufräumarbeiten
erledigt:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Die fehlenden <em>,,Musik&quot;</em>&ndash;Genres <em>,,Vocal&quot;</em> und <em>,,Speech&quot;</em> werden
manuell eingefügt.</li>
<li>Bei dem momentanen Vorgehen landen unter Umständen weitere
<em>,,Music&quot;</em>&ndash;Knoten auf der ersten Ebene. Diese werden entfernt.</li>
<li>Alle Genres die auf <em>,,core&quot;</em> enden werden aufgebrochen und dem Knoten
<em>,,core&quot;</em> auf erster Ebene hinzugefügt. Damit werden meist ähnliche Genres
wie <em>,,Metalcore&quot;</em> und <em>,,Grindcore&quot;</em>  zusammengefasst.</li>
</ol>
</div></blockquote>
<p>Der resultierende Baum ist im Anhang <a class="reference internal" href="rst/index.html#genre-graph-vis"><em>Bilder des Genregraphen</em></a> in verschiedenen
Detailstufen visualisiert.  Er besitzt auf der ersten Ebene 1044 Untergenres.
Die tiefste Verschachtelung erreicht das Genre <em>,,New Wave of new Wave&quot;</em> mit
einer Tiefe von fünf.</p>
</div>
<div class="section" id="zuordnung-von-genres">
<h4>5.2.3 Zuordnung von Genres<a class="headerlink" href="#zuordnung-von-genres" title="Permalink to this headline">¶</a></h4>
<p>Die Normalisierung des Genres ist nun mit dem aufgebauten Baum recht effizient
möglich.  Zuerst muss das Eingabegenre in Untergenres aufgeteilt werden, denn
oft sind mehrere Genres in einem einzelnen String zusammengefasst, die durch
bestimmte Zeichen getrennt sind. Ein Beispiel:</p>
<blockquote>
<div><em>,,Rock, Reggae / Alternative Rock, Ska, Punk&quot;</em></div></blockquote>
<p>Jedes dieser Untergenres wird dann mittels eines regulären Ausdruckes in einzelne
Wörter aufgeteilt. Die Wörter werden noch in die kleingeschriebene Form
gebracht. In der Python&ndash;Listen Syntax sähe das obige Beispiel dann so aus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[[</span><span class="s">&#39;rock&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;reggae&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;alternative&#39;</span><span class="p">,</span> <span class="s">&#39;rock&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;ska&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;punk&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Die einzelnen Wortlisten können jetzt in <em>Pfade</em> umgewandelt werden.
Dazu werden zuerst folgende Variablen initialisiert:</p>
<div class="figure align-center">
<center><blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>Variable</em></th>
<th class="head"><em>Beschreibung</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">root</span></tt></td>
<td>Der momentane Wurzelknoten. Anfangs initialisiert auf <em>,,Music&quot;</em>.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">paths</span></tt></td>
<td>Eine leere lineare Liste mit Pfaden. Dient als Speicher für Resultate.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">mask</span></tt></td>
<td>Eine Liste mit Wahrheitswerten. Genauso lang wie die Wortliste. <br /></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Die Wahrheitswerte werden mit <em>False</em> initialisiert. <br /></td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Die Liste wird genutzt um gefundene Wörter an  <br /></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>dem entsprechenden Index <em>,,abzuhaken&quot;</em>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">path_result</span></tt></td>
<td>Eine Liste, die an die nächste Rekursionsstufe weitergegeben wird. <br /></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Sie speichert die Indizes des momentan aufgebauten Pfades. <br /></td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Anfangs initialisiert auf ein leere Liste.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</center></div><p>Nach diesen Vorbereitungen wird eine rekursive Suche gestartet:</p>
<ol class="arabic simple">
<li>Finde alle Kinder von <tt class="docutils literal"><span class="pre">root</span></tt>, deren Untergenres in der Wortliste vorkommen.
Wenn das entsprechende Untergenre noch nicht in <tt class="docutils literal"><span class="pre">mask</span></tt> abgehakt wurde, wird
es in einer temporären Liste vermerkt.</li>
<li>Ist diese temporäre Liste dann  leer und die <tt class="docutils literal"><span class="pre">path_result</span></tt>&ndash;Liste nicht
leer, so wird die <tt class="docutils literal"><span class="pre">path_result</span></tt>&ndash;Liste zur <tt class="docutils literal"><span class="pre">paths</span></tt>&ndash;Liste hinzugefügt.
Trifft dieser Fall ein, so ist dieser Zweig der Rekursion beendet.</li>
<li>Es wird über jedes Kindelement in der temporären Liste iteriert. Bei jeder
Iteration wird:<ol class="upperalpha">
<li>Eine Kopie der <tt class="docutils literal"><span class="pre">path_result</span></tt>&ndash;Liste wird erstellt, bei der der Index des
aktuellen Kindelements am Ende hinzugefügt wird.</li>
<li>Eine Kopie der <tt class="docutils literal"><span class="pre">mask</span></tt>&ndash;Liste wird erstellt, in der das vom Kind
repräsentierte Wort <em>,,abgehakt&quot;</em> (der entsprechende Index wird auf
<em>True</em> gesetzt) wird.</li>
<li>Das Kind wird als neuer Wurzelknoten angenommen und es wird wie bei 1)
weitergemacht.</li>
</ol>
</li>
<li>Nachdem alle Zweige der Rekursion zum Rekursionsstopp gefunden haben,
stehen alle validen Pfade, als Tupel von Indizes, in <tt class="docutils literal"><span class="pre">paths</span></tt>.</li>
</ol>
<div class="figure align-center" id="fig-match-example">
<a class="reference internal image-reference" href="../../_images/tree_match_example.svg"><img alt="Beispielablauf des Zuordnungs--Algorithmus" src="../../_images/tree_match_example.svg" width="100%" /></a>
<p class="caption">Beispiel-Ablauf des Zuordnungs&ndash;Algorithmus an der Eingabe ,,Alternative
Rock / Reggae”. In den Knoten ist die jeweils die momentante Maske eingetragen, an
den Kanten jeweils die aktuelle mask und der bisher gebildete Pfad.</p>
</div>
<p>In  wird ein Beispiel dieses Verfahrens mit dem Genre
<em>,,Alternative Rock / Reggae&quot;</em> gegeben.  <br /> Die passenden Pfade sind in diesem
Fall also <tt class="docutils literal"><span class="pre">Reggae</span> <span class="pre">{0}</span></tt> und <tt class="docutils literal"><span class="pre">Alternative</span> <span class="pre">Rock</span> <span class="pre">{2,</span> <span class="pre">0}</span></tt>.  Es ist zu bemerken,
dass <tt class="docutils literal"><span class="pre">Rock</span> <span class="pre">{2}</span></tt> allein zwar ebenfalls ein valider Pfad ist, aber als eine
Untermenge von <tt class="docutils literal"><span class="pre">Alternative</span> <span class="pre">Rock</span> <span class="pre">{2,</span> <span class="pre">0}</span></tt> nicht in der Ergebnismenge ist.</p>
</div>
<div class="section" id="vergleichen-der-unterschiedlichen-genrepfad-mengen">
<span id="single-dist"></span><h4>5.2.4 Vergleichen der unterschiedlichen Genrepfad&ndash;Mengen<a class="headerlink" href="#vergleichen-der-unterschiedlichen-genrepfad-mengen" title="Permalink to this headline">¶</a></h4>
<p>Um zwei einzelne Pfade miteinander zu Vergleich wird folgendermaßen vorgegangen:</p>
<ul class="simple">
<li>Zähle die Anzahl an Punkten, in denen sich der Pfad überdeckt.
Für <tt class="docutils literal"><span class="pre">(192,</span> <span class="pre">1,</span> <span class="pre">8)</span></tt> und <tt class="docutils literal"><span class="pre">(192,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">8)</span></tt> wäre dies <span class="math">\(2\)</span>.</li>
<li>Teile die Anzahl durch die Länge, des längeren beider Pfade.</li>
<li>Die daraus gewonnene Ähnlichkeit wird von <span class="math">\(1.0\)</span> abgezogen um die Distanz
zu erhalten.</li>
</ul>
<p>In <em>libmunin</em> sind zwei Distanzfunktionen erhalten, welche diese Methode nutzt um
zwei Mengen mit Genrepfaden zu vergleichen.</p>
<p><tt class="docutils literal"><span class="pre">GenreTree</span></tt>: Vergleicht jeden Genrepfad in den Mengen <em>A</em> und <em>B</em> mittels oben
genannter Methode miteinander. Die minimalste Distanz wird zurückgegeben.  Als
Optimierung wird frühzeitig abgebrochen wenn eine Distanz von <span class="math">\(0\)</span>
erreicht wird.</p>
<p>Diese Distanzfunktion eignet sich für eher kurze Genre-Beschreibungen, wie sie
in vielen Musiksammlungen vorkommen. Meist ist dort ein Lied als <em>rock</em> oder
<em>metal</em> eingetragen, ohne Unterscheidung von Untergenres. Deshalb geht diese
Distanzfunktion davon aus wenige Übereinstimmungen zu finden &ndash;- sollten welche
vorkommen, so werden diese gut bewertet.</p>
<p>Setzt man voraus, dass <em>d</em> die unter <a class="reference internal" href="rst/index.html#single-dist">5.2.4</a> erwähnte Distanzunktion
ist,  so berechnet sich die finale Distanz durch:</p>
<div class="math">
\[D_{min}(A, B) = min\!\left\{d(a, b) \colon a, b \in A \times B, a \neq b\right\}\]</div>
<p><tt class="docutils literal"><span class="pre">GenreTreeAvg</span></tt>: Seien <em>A</em> und <em>B</em> zwei Mengen mit Genrepfaden. <em>A</em> ist dabei
die größere Menge und <em>B</em> die kleinere, falls die Mengen eine unterschiedliche
Mächtigkeit besitzen, dann gilt hier:</p>
<div class="math">
\[D_{avg}(A, B) = \frac{1}{\vert A\vert} \times \displaystyle\sum\limits_{a \in A} min\!\left\{ d(a, b) \colon b \in B, a \neq b\right\}\]</div>
<p>Diese Distanzfunktion eignet sich für <em>,,reichhaltig&quot;</em> befüllte
Genrebeschreibungen, bei denen auch ein oder mehrere Untergenres vorhanden sind.
Ein Beispiel dafür wäre: <em>,,Country Rock/Folk/Rockabilly&quot;</em>. Die
Distanzfunktion geht also davon aus zumindest teilweise Überdeckungen in den
Daten vorzufinden. <br />
Je nach Daten die es zu verarbeiten gilt, kann der Nutzer der Bibliothek eine
passende Distanzunktion auswählen.</p>
</div>
<div class="section" id="probleme">
<h4>5.2.5 Probleme<a class="headerlink" href="#probleme" title="Permalink to this headline">¶</a></h4>
<p>Insgesamt funktioniert dieser Ansatz relativ gut. Die meisten Genre werden
zufriedenstellend in Pfade normalisiert, die performant verglichen werden können.</p>
<p>Folgendes Problem wird allerdings noch nicht zufriedenstellend gelöst:
Es wird davon ausgegangen, dass Genres die ähnlich sind auch ähnlich heißen.
Eine Annahme, die zwar oft, aber nicht immer wahr ist. So sind die Genres
<em>Alternative Rock</em> und <em>Grunge</em> sehr ähnlich &ndash;- der obige Ansatz würde hier
allerdings eine Distanz von <span class="math">\(0\)</span> liefern. Auch Genres wie <em>,,Rock'n'Roll</em>
würde ähnlich schlechte Resultate liefern, da sie kaum sinnvoll aufgebrochen
werden können.</p>
<p>Eine mögliche Lösung wäre eine Liste von <em>,,synonymen&quot;</em> Genres die
Querverbindungen im Baum erlauben würden.  Allerdings wäre eine solche Liste von
Synonymen relative schwer automatisch zu erstellen.</p>
</div>
</div>
<div class="section" id="schlusselwortextraktion">
<h3>5.3 Schlüsselwortextraktion<a class="headerlink" href="#schlusselwortextraktion" title="Permalink to this headline">¶</a></h3>
<p>Eine Idee bei <em>libmunin</em> ist es auch die Liedtexte eines Liedes einzubeziehen,
um Lieder, die änhlichen <em>Themen</em> behandeln näher beieinander im Graphen zu
gruppieren. Sollten zwei Lieder nicht die selben Themen behandeln, so soll sich
zumindest die gleiche Sprache sich positiv auf die Distanz auswirken.</p>
<p>Um die Themen effizient zu vergleichen, extrahiert <em>libmunin</em> aus den Liedtexten
die wichtigsten <em>Schlüsselwörter</em> mittels des <tt class="docutils literal"><span class="pre">KeywordProviders</span></tt>. Diese
Phrasen sollen den eigentlichen Inhalt möglichst gut approximieren, ohne dabei
schwer vergleichbar zu sein.</p>
<p><em>Anmerkung:</em> Im Folgenden ist von <em>Schlüsselwörtern</em> die Rede. Ein einzelnes
<em>Schlüsselwort</em>, wie <em>,,dunkle Schwingen&quot;</em>, kann aber aus mehreren Wörtern
bestehen.</p>
<div class="section" id="der-rake-algorithmus">
<h4>5.3.1 Der RAKE&ndash;Algorithmus<a class="headerlink" href="#der-rake-algorithmus" title="Permalink to this headline">¶</a></h4>
<p>Zur Extrahieren von Schlüsselwörtern aus Texten gibt es eine Vielzahl von
Algorithmen.  Der verwendete Algorithmus zur Schlüsselwörter&ndash;Extrahierung ist
bei <em>libmunin</em> der relativ einfach zu implementierende RAKE&ndash;Algorithmus
(vorgestellt in <a class="reference internal" href="rst/index.html#berry2010text" id="id8">[2]</a>). Zwar könnte man mit anderen Algorithmen
hier bessere Ergebnisse erreichen, diese sind aber schwerer zu implementieren
(was die Anpasspartkeit verschlechtert) und sind in den meisten Fällen von
sprachabhängigen Corpora (Wortdatenbanken) abhängig.</p>
<p><em>Beschreibung des RAKE&ndash;Algorithmus:</em></p>
<ol class="arabic">
<li><p class="first">Aufteilung des Eingabetextes in Sätze, anhand von Interpunktion und
Zeilenumbrüchen.</p>
</li>
<li><p class="first">Extrahierung der <em>Phrasen</em> aus den Sätzen.  Eine <em>Phrase</em> ist hier definiert
als eine Sequenz von Nichtstoppwörtern.  Um Stoppwörter zu erkennen, muss
eine von der Sprache abhängige Stoppwortliste geladen werden. Zu diesem Zweck
hat <em>libmunin</em> 17 Stoppwortlisten in verschiedenen Sprachen eingebaut. Die
Sprache selbst wird durch das Python Modul <tt class="docutils literal"><span class="pre">guess-language-spirit</span></tt>
<a class="reference internal" href="rst/index.html#guess-language" id="id9">[Link&ndash;12]</a> anhand verschiedener Sprachcharakteristiken
automatisch erraten. Zudem werden lange Wörter mittels <tt class="docutils literal"><span class="pre">PyEnchant</span></tt>
<a class="reference internal" href="rst/index.html#pyenchant" id="id10">[Link&ndash;13]</a> in einem Wörterbuchs nachgeschlagen um die Sprache
rauszufinden sofern die <tt class="docutils literal"><span class="pre">Enchant</span></tt>&ndash;Bibliothek samt Wörterbuch für die
entsprechende Sprache <a class="reference internal" href="rst/index.html#enchant" id="id11">[Link&ndash;14]</a> installiert ist .</p>
</li>
<li><p class="first">Berechnung eines <em>Scores</em> für jedes Wort in einem Phrase aus dem <em>Degree</em> und
der <em>Frequenz</em> eines Wortes (<span class="math">\(P\)</span> ist dabei die Menge aller Phrasen):</p>
<div class="math">
\[\begin{split}degree(word) = \sum_{p \in P} \left\{\begin{array}{cl} \vert p\vert, &amp; \mbox{falls } word \in p\\ 0, &amp; \mbox{sonst} \end{array}\right.\end{split}\]</div>
<div class="math">
\[\begin{split}freq(word) = \sum_{p \in P} \left\{\begin{array}{cl} min \left\{2, \frac{\vert word\vert}{3}\right\}, &amp; \mbox{falls } word \in p\\ 0, &amp; \mbox{sonst} \end{array}\right.\end{split}\]</div>
<div class="math">
\[score(word) = \frac{degree(word) + freq(word)^{1.6}}{freq(word)}\]</div>
</li>
<li><p class="first">Für jeden Phrase wird nun ein <em>Score</em> berechnet. Dieser ist definiert als die
Summe aller Wörter&ndash;<em>Scores</em> innerhalb des Phrases. Die derart bewerteten
Phrasen werden absteigend sortiert als <em>Schlüsselwörter</em> ausgegeben.
<em>Schlüsselwörter</em> mit einem <em>Score</em> kleiner <span class="math">\(2.0\)</span> werden ausgesiebt.</p>
</li>
</ol>
<p>Es wurden zudem einige Änderungen zum in <a class="reference internal" href="rst/index.html#berry2010text" id="id12">[2]</a> vorgestellten
Algorithmus vorgenommen, um diesen besser auf kleine Dokumente wie Liedtexte
abzustimmen:</p>
<ul class="simple">
<li>Im Original werden Sätze nicht anhand von Zeilenumbrüchen aufgebrochen.  Die
meisten Liedtexte bestehen aus einzelnen Versen, die nicht durch Punkte
getrennt sind, sondern durch eine neue Zeile abgegrenzt werden.</li>
<li>Um die Ergebnisse leichter vergleichen zu können, werden die einzelnen Wörter
nach dem Extrahieren noch auf ihren Wortstamm reduziert. Dabei wird der
sprachsensitive <em>Snowball&ndash;Stemmer</em> <a class="reference internal" href="rst/index.html#porter2001snowball" id="id13">[9]</a> verwendet.</li>
<li>Im Original wird der <em>Wort&ndash;Score</em> als <span class="math">\(\frac{degree(word)}{freq(word)}\)</span>
berechnet. Der von <em>libmunin</em> berechnete <em>Score</em> gewichtet die Wortfrequenz
stärker. Der Exponent von <span class="math">\(1.6\)</span> wurde willkürlich nach einigen Tests
gewählt: Mit diesem Exponent erscheint das Schlüsselwort <em>Yellow Submarine</em>
an erster Stelle im Liedtext von <em>,,Yellow Submarine&quot;</em> der <em>Beatles</em>.</li>
<li>Da sich viele Ausdrücke in Liedtexten wiederholen, kamen während der
Entwicklung viele Schlüsselwörter in verschiedenen Variationen mehrmals vor.
Oft waren diese dann eine Untermenge eines anderen Schlüsselwortes (Beispiel:
<em>Yellow</em> und <em>Submarine</em> sind ein Teil von <em>Yellow Submarine</em>). Daher werden
in einem nachgelagerten Schritt diese redundanten Phrasen entfernt.</li>
<li>Die Wortfrequenz ist im Original unabhängig von der Länge des Wortes. Diese
Änderung gewichtet längere Wörter stärker, unter der gewagten Annahme, dass
längere Wörter auch wichtiger sind.</li>
</ul>
<p><strong>Vergleich der einzelnen Schlüsselphrasenmengen:</strong></p>
<p>Die einzelnen Mengen von Schlüsselwörter werden unter der Prämisse verglichen,
dass exakte Übereinstimmungen, durch den riesigen Wortschatz, selten sind.</p>
<ul>
<li><p class="first">Zu einem Drittel geht der Vergleich der Sprache in die Distanz ein. Ist die
Sprache gleich, so wird hier eine Teildistanz von <span class="math">\(1\)</span> angenommen,
andernfalls ist die Gesamtdistanz <span class="math">\(0\)</span>, da dann auch ein Vergleich der
einzelnen Schlüsselwörter nicht mehr sinnvoll ist.</p>
</li>
<li><p class="first">Die restlichen zwei Drittel errechnen sich aus der Übereinstimmung der
Schlüsselwörter. Für zwei Schlüsselwörter (eine Menge von Wörtern) <em>A</em> und <em>B</em>
errechnet sich die Distanz folgendermaßen:</p>
<div class="math">
\[d_{kwd}(A, B) = 1 - \frac{\vert A\cup B\vert}{max\left\{\vert A\vert, \vert B\vert\right\}}\]</div>
<p>Alle Schlüsselwörter werden damit untereinander verglichen. Die minimalste
dabei gefundene Distanz ist die finale Teildistanz.</p>
</li>
</ul>
</div>
<div class="section" id="ergebnisse">
<h4>5.3.2 Ergebnisse<a class="headerlink" href="#ergebnisse" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="table-keywords">
<center><table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="30%" />
<col width="15%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Score</th>
<th class="head">Schlüsselwörter <em>(Wandern)</em></th>
<th class="head">Score</th>
<th class="head">Schlüsselwörter <em>(Yellow Submarine)</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(9.333\)</span></td>
<td><em>gerne  stille  stehn</em></td>
<td><span class="math">\(22.558\)</span></td>
<td><em>yellow  submarin</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(5.778\)</span></td>
<td><em>wandern</em></td>
<td><span class="math">\(20.835\)</span></td>
<td><em>full  speed  ahead  mr</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(5.442\)</span></td>
<td><em>müllers  lust</em></td>
<td><span class="math">\(8.343\)</span></td>
<td><em>live  beneath</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(5.247\)</span></td>
<td><em>müde  drehn</em></td>
<td><span class="math">\(5.247\)</span></td>
<td><em>band  begin</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(5.204\)</span></td>
<td><em>niemals  fiel</em></td>
<td><span class="math">\(3.297\)</span></td>
<td><em>sea</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(5.204\)</span></td>
<td><em>herr  meister</em></td>
<td><span class="math">\(3.227\)</span></td>
<td><em>green</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(5.204\)</span></td>
<td><em>frau  meisterin</em></td>
<td><span class="math">\(2.797\)</span></td>
<td><em>captain</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(5.074\)</span></td>
<td><em>muntern  reihn</em></td>
<td><span class="math">\(2.551\)</span></td>
<td><em>sail</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(5.031\)</span></td>
<td><em>schlechter  müller</em></td>
<td><span class="math">\(2.551\)</span></td>
<td><em>blue</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(5.031\)</span></td>
<td><em>wanderschaft  bedacht</em></td>
<td><span class="math">\(2.551\)</span></td>
<td><em>cabl</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(3.430\)</span></td>
<td><em>wasser</em></td>
<td><span class="math">\(2.551\)</span></td>
<td><em>life</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(3.430\)</span></td>
<td><em>steine</em></td>
<td><span class="math">\(2.516\)</span></td>
<td><em>sky</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(2.016\)</span></td>
<td><em>tanzen</em></td>
<td><span class="math">\(2.516\)</span></td>
<td><em>aye</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(2.016\)</span></td>
<td><em>frieden</em></td>
<td><span class="math">\(2.016\)</span></td>
<td><em>friend</em></td>
</tr>
<tr class="row-even"><td><span class="math">\(2.016\)</span></td>
<td><em>gelernt</em></td>
<td><span class="math">\(2.016\)</span></td>
<td><em>aboard</em></td>
</tr>
<tr class="row-odd"><td><span class="math">\(2.016\)</span></td>
<td><em>schwer</em></td>
<td><span class="math">\(2.016\)</span></td>
<td><em>boatswain</em></td>
</tr>
</tbody>
</table>
<p class="caption">Extrahierte Schlüsselwörter aus dem Volkslied
,,Das Wandern ist des Müllers Lust“ (links) und dem
Beatles&ndash;Song ,,Yellow Submarine“ (rechts).</p>
</center></div><div class="figure align-center" id="table-lyrics-wandern">
<span id="table-keywords"></span><center><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Das Wandern ist des Müllers Lust,</td>
<td>Das sehn wir auch den Rädern ab,</td>
</tr>
<tr class="row-even"><td>Das Wandern!</td>
<td>Den Rädern!</td>
</tr>
<tr class="row-odd"><td>Das muß ein schlechter Müller sein,</td>
<td><br /></td>
</tr>
<tr class="row-even"><td>Dem niemals fiel das Wandern ein,</td>
<td>Die gar nicht gerne stille stehn,</td>
</tr>
<tr class="row-odd"><td>Das Wandern.</td>
<td>Die Steine selbst, so schwer sie sind,</td>
</tr>
<tr class="row-even"><td><br /></td>
<td>Die Steine!</td>
</tr>
<tr class="row-odd"><td>Vom Wasser haben wir’s gelernt,</td>
<td>Sie tanzen mit den muntern Reihn</td>
</tr>
<tr class="row-even"><td>Vom Wasser!</td>
<td>Und wollen gar noch schneller sein,</td>
</tr>
<tr class="row-odd"><td>Das hat nicht Rast bei Tag und Nacht,</td>
<td>Die Steine.</td>
</tr>
<tr class="row-even"><td>Ist stets auf Wanderschaft bedacht,</td>
<td><br /></td>
</tr>
<tr class="row-odd"><td>Das Wasser.</td>
<td>O Wandern, Wandern, meine Lust,</td>
</tr>
<tr class="row-even"><td><br /></td>
<td>O Wandern!</td>
</tr>
<tr class="row-odd"><td>Die sich mein Tag nicht müde drehn,</td>
<td>Herr Meister und Frau Meisterin,</td>
</tr>
<tr class="row-even"><td>Die Räder.</td>
<td>Laßt mich in Frieden weiter ziehn</td>
</tr>
<tr class="row-odd"><td><em>(oben rechts weiter)</em></td>
<td>Und wandern.</td>
</tr>
</tbody>
</table>
<p class="caption">Liedtext des Volksliedes ,,Das Wandern ist des Müllers Lust“.</p>
</center></div><p id="table-lyrics-wandern">In Abb.  sind die extrahierten Schlüsselwörter aus zwei
Liedern aufgelistet.</p>
<p>Zur Referenz ist unter Abb.  der Liedtextes des
Volkliedes ,,Das Wandern ist des Müllers Lust&quot; abgedruckt. Der Text von
<em>,,Yellow Subarmine&quot;</em> wird aus lizenzrechtlichen Gründen hier nicht
abgedruckt.</p>
<p>Wie man in Abb.  sieht, werden längere Phrasen automatisch
besser bewertet &ndash;- deren <em>Score</em> berechnet sich ja aus der Summe ihrer Wörter.
Auch sieht man, dass viele unwichtige Wörter wie <em>aboard</em> trotz Stoppwortlisten
noch in das Ergebniss aufgenommen werden.</p>
</div>
<div class="section" id="id14">
<h4>5.3.3 Probleme<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Teilweise liefert diese Provider&ndash;Distanzfunktions&ndash;Kombination bereits
interessante Ergebnisse. So werden die beiden staatskritischen, deutschen Texte
<em>,,Hey Staat&quot;</em> von <em>Hans Söllner</em> und <em>,,Lieber Staat&quot;</em> von <em>Farin Urlaub</em> mit
einer relativ niedrigen Distanz von gerundet <span class="math">\(0.4\)</span> bewertet.</p>
<p>Doch nicht bei allen Texten funktioniert die Extrahierung so gut. Nimmt man den
Ausdruck <em>,,God save the Queen!&quot;</em>, so wird <em>RAKE</em> diesen nicht als gesamten
Schlüsselphrase erkennen. Stattdessen werden zwei einzelne Phrasen generiert:
<em>,,God save&quot;</em> und <em>,,Queen&quot;</em>, da <em>,,the&quot;</em> ein einglisches Stoppwort ist.</p>
<p>Andererseits entstehen auch oft Schlüsselwörter, die entweder unwichtig <em>(,,mal
echt&quot;)</em>, sinnentfremdet (<em>,,gerne still stehen&quot;</em> obwohl im Text oben <em>,,nicht&quot;</em>
davor steht) oder stark kontextspezifisch <em>(,,schlechter Müller&quot;)</em> sind. Da ein
Computer den Text nicht verstehen kann, lässt sich das kaum vermeiden.</p>
<p>Auch gemischtsprachige Liedtexte lassen sich nur schwer untersuchen, da immer
nur eine Stoppwortliste geladen werden kann. Für Liedtexte mit starkem Dialekt
(wie von <em>Hans Söllner</em>) greift auch die normale hochdeutsche Stoppowortliste
nicht.</p>
</div>
</div>
<div class="section" id="moodbar">
<h3>5.4 Moodbar<a class="headerlink" href="#moodbar" title="Permalink to this headline">¶</a></h3>
<p>Die ursprünglich als Navigierungshilfe in Audioplayern gedachte Moodbar (siehe
<a class="reference internal" href="rst/index.html#wood2005techniques" id="id15">[12]</a> für genauere Informationen) wird in <em>libmunin</em> neben
der Beats&ndash;Per&ndash;Minute Bestimmung als einfache Form der Audioanalyse eingesetzt.
Kurz zusammengefasst wird dabei ein beliebiges Audiostück zeitlich in 1000
Blöcke unterteilt. Für jeden dieser Blöcke wird ein Farbwert (als RGB&ndash;Tripel)
bestimmt. Der Rotanteil bestimmt dabei den Anteil niedriger Frequenzen, der
Grünanteil den Anteil mittleren Frequenzen und der Blauanteil den Anteil von
hohen Frequenzen. Die Farbe Türkis deutet daher auf hohe und mittlere Frequenzen
in einem Block hin &ndash;- E&ndash;Gitarren haben häufig diese Farbe in der Moodbar.
Akustikgitarren erscheinen dafür meist in einem dunklem Rot.</p>
<p>Die Namensgebung des Verfahrens ist ein wenig irreführend. Man kann hier
keineswegs die subjektive Stimmung in einem Lied herauslesen. Lediglich die
Bestimmung einzelner Instrumente ist als Annäherung möglich. Nach Meinung des
Autors sollte man das Verfahren daher eher <em>,,frequencebar&quot;</em> oder Ähnliches
nennen. Um aber auf die Einführung eines neuen Begriffes zu verzichten wird die
Namensgebung des Erfinders verwendet.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/mood_avril.svg"><img alt="Beispiel--Moodbar von ,,Avril Lavigne -  Knockin' on Heaven's Door“" src="../../_images/mood_avril.svg" width="100%" /></a>
<p class="caption">Beispiel&ndash;Moodbar von ,,Avril Lavigne - Knockin' on Heaven's Door“.  Ein
Lied bei dem hauptsächlich eine Akustikgitarre (rot) und Gesang (grünlich)
im Vordergrund steht. Der Gesang setzt etwa bei 10% ein. Die Grafik wurde
durch ein eigens zu diesem Zwekc geschriebenes Script gerendert. Deutlich
sichtbar sind die einzelnen Pausen zwischen den Akkorden.</p>
</div>
<div class="section" id="vergleich-von-moodbars">
<h4>5.4.1 Vergleich von Moodbars<a class="headerlink" href="#vergleich-von-moodbars" title="Permalink to this headline">¶</a></h4>
<p>Das Vergleichen verschiedener Moodbars gestaltet sich aufgrund der hohen
Länge der einzelnen RGB&ndash;Vektoren als schwierig. In einem vorgelagerten
Analyseschritt wird daher versucht, die markanten Merkmale der einzelnen
Vektoren zu extrahieren. Dieser Analyseschritt wird dabei durch den
<tt class="docutils literal"><span class="pre">MoodbarProvider</span></tt> getätigt.</p>
<p>Vor der eigentlichen Verarbeitung wird jeder Farbkanal in einzelne Blöcke
aufgeteilt, von der jeweils das arithmetische Mittel gebildet wird. So wird der
ursprüngliche 1000 Werte lange Vektor in (momentan) 20 einzelne, <em>handlichere</em>
Werte aufgeteilt. Bei einer durchschnittlichen Liedlänge von 4 Minuten entspricht
das immerhin 12 Sekunden pro Block, was für gewöhnliche Lieder ausreichend ist.</p>
<p>Nach einigen subjektiven Tests haben sich folgende Merkmale als <em>vergleichbar</em>
erwiesen:</p>
<ul>
<li><p class="first"><strong>Differenzsumme:</strong> Für jeden Farbkanal wird die Summe der Differenzen zu den
jeweiligen vorherigen Blockwert gebildet (C ist der jeweilige Farbkanal):</p>
<div class="math">
\[\sum_{i=1}^{\vert C\vert} \vert C_{i} - C_{i-1}\vert\]</div>
<p>Dieser Wert soll die grobe <em>,,Sprunghaftigkeit&quot;</em> des Liedes beschreiben.
Ändern sich die Werte für diesen Farbkanal kaum, so ist der Wert niedrig.
Liegen hohe Änderungen zwischen jedem Block vor, so steigt dieser Wert bis zu
seinem maximalen Wert von <span class="math">\((20 - 1) \times 255 = 4845\)</span>.</p>
</li>
<li><p class="first"><strong>Histogramm:</strong> Für jeden Farbkanal wird eine Häufigkeitsverteilung, also ein
Histogramm, abgespeichert. Jeder Farbwert wird dabei auf einen von fünf
möglichen Bereichen, die jeweils 51 Werte umfassen, aufgeteilt.
So wird für jeden Farbkanal eine relativ einfach zu vergleichende Verteilung
der Frequenzen abgespeichert.</p>
</li>
<li><p class="first"><strong>Dominanten Farben:</strong> Wie bereits erwähnt, ist es manchmal möglich bestimmte
Instrumente visuell anhand deren charakteristischen Farbe zu erkennen. Das
kann man sich beim Vergleichen zu Nutze machen, denn ähnliche Instrumente
(ergo bestimmte, charakteristische Farben) deuten auf ähnliche Musikstile hin.
Der <tt class="docutils literal"><span class="pre">MoodbarProvider</span></tt> teilt daher jeden Farbkanal in 15er&ndash;Schritten in
einzelne Bereiche auf. Jede Farbkombination wird dann einem dieser Bereich
zugeordnet. Die 15 am häufigsten zusammen vorkommenden Tripel werden
abgespeichert.</p>
</li>
<li><p class="first"><strong>Schwarzanteil:</strong> Gesondert werden sehr dunklen Farben behandelt. Haben alle
Farbkanäle eines RGB&ndash;Tripels einen Wert kleiner 30, so wird die Farbe nicht
gezählt, sondern auf einen <em>Schwarzanteil</em>&ndash;Zähler aufaddiert.  Geteilt durch
1000 ergibt sich daraus der Anteil des Liedes, der (beinahe) <em>still</em> ist.</p>
</li>
<li><p class="first"><strong>Durchschnittliches Minimun/Maximum:</strong> Von jedem Block wird das Minimum/Maximum
bestimmt.  Die Summe über jeden so bestimmten Wert, geteilt durch die Anzahl
der Blöcke ergibt das durschnittliche Minimun/Maximum. Für jeden Farbkanal
ergibt sich so ein Wert, der zwischen <span class="math">\(0\)</span> und <span class="math">\(255\)</span> liegt. Dieser
sagt aus, in welchem Bereich sich die <em>,,Frequenzen&quot;</em> im jeweiligen Farbkanal
bewegen.</p>
</li>
</ul>
<div class="figure align-center" id="table-moodbar-list">
<center><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="16%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Gewichtung</th>
<th class="head"><em>ungewichtete</em> Distanzfunktion <span class="math">\(d(a, b)\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Differenzsumme</em></td>
<td><span class="math">\(13,5\%\)</span></td>
<td><span class="math">\(1 - \sqrt{\frac{\vert a - b\vert}{50}}\)</span></td>
</tr>
<tr class="row-odd"><td><em>Histogramm</em></td>
<td><span class="math">\(13,5\%\)</span></td>
<td><span class="math">\(1 - \frac{\sum_{x \in \vv{a} - \vv{b}}\vert x\vert}{5 \times 255}\)</span></td>
</tr>
<tr class="row-even"><td><em>Dominante Farben</em></td>
<td><span class="math">\(63,0\%\)</span></td>
<td><span class="math">\(\frac{\vert a \cup b\vert}{max\left\{\vert a \vert, \vert b \vert\right\}}\)</span></td>
</tr>
<tr class="row-odd"><td><em>Schwarzanteil</em></td>
<td><span class="math">\(5,0\%\)</span></td>
<td><span class="math">\(1 - \sqrt{\frac{\vert a - b\vert}{50}}\)</span></td>
</tr>
<tr class="row-even"><td><em>Durchschnittliches Minimum/Maximum</em></td>
<td><span class="math">\(5,0\%\)</span></td>
<td><span class="math">\(1 - \sqrt{\frac{\vert a - b\vert}{255}}\)</span></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><span class="math">\(\sum 100\%\)</span></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="caption">Auflistung der einzelnen Werte die der Moodbar&ndash;Provider ausliest
und deren dazugehörige Distanzfunktion, sowie deren Gewichtung in
der Gesamtdistanz. ,,a“ und ,,b“ sind Skalare, mit Ausnahme der
Histogramm&ndash;Eingabewerte und der dominanten Farben. Dort sind ,,a“
und ,,b“ die einzelnen Farbkanäle als Vektor, bzw. eine Menge von
Farben. Zur Bildung der Gesamtdistanz werden die einzelnen Werte
über einen gewichteten Mittelwert verschmolzen.</p>
</center></div><p id="table-moodbar-list">In  wird eine Auflistung der einzelnen Werte gegeben,
die der <tt class="docutils literal"><span class="pre">Moodbar-Provider</span></tt> generiert. Daneben werden auch die entsprechenden
Gewichtungen und Distanzfunktionen gegeben, mit dem die
Moodbar&ndash;Distanzfunktion, die einzelnen Werte verrechnet.</p>
<p>Am subjektiv <em>vergleichbarsten</em> erwiesen sich die dominanten Farben in einem
Lied. Die zwischenzeitlich aufgekommene Idee bestimmte markante Farbwertbereiche
bestimmten Instrumenten automatisch zuzuordnen erwies sich als unpraktikabel und
extrem ungenau.</p>
</div>
<div class="section" id="id16">
<h4>5.4.2 Probleme<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="fig-mood-yellow-submarine">
<a class="reference internal image-reference" href="../../_images/mood_yellow_submarine.svg"><img alt="Diesselbe Moodbar bei unterschiedlichen Encoding der Audiodaten" src="../../_images/mood_yellow_submarine.svg" width="100%" /></a>
<p class="caption">Diesselbe Moodbar bei unterschiedlichen Encoding der Audiodaten. Oben das
Beatles&ndash;Lied ,,Yellow Submarine“ als FLAC enkodiert, darunter dasselbe Lied
mit relativ stark komprimierter MP3&ndash;Enkodierung. Die von libmunin
berechnete Distanz ist hier etwa 0.01.</p>
</div>
<div class="figure align-center" id="fig-mood-rammstein-tier">
<a class="reference internal image-reference" href="../../_images/mood_rammstein_tier.svg"><img alt="Moodbar einer Live und einer Studioversion von ,,Rammstein --- Tier“" src="../../_images/mood_rammstein_tier.svg" width="100%" /></a>
<p class="caption">Moodbar einer Live und einer Studioversion von ,,Rammstein &ndash;- Tier“. Oben
die Studioversion, unten die Liveversion.  Hier ist die von libmunin
errechnete Distanz immerhin bei 0.32.</p>
</div>
<p>Das Hauptproblem ist, dass das Verfahren ursprünglich nicht zum Vergleichen von
Audiodaten ausgelegt war und vom Autor lediglich dafür <em>,,missbraucht&quot;</em> wurde.
Wichtige Informationen wie die eigentliche Stimmung in dem Lied (von <em>dunkel</em>
bis <em>positiv)</em> bis hin zur Rhythmus des Liedes lassen sich nicht davon ablesen.
Lediglich die durchschnittliche Geschwindigkeit wird vom <tt class="docutils literal"><span class="pre">BPMProvider</span></tt>
erfasst. Dieser muss aber die ganze Datei noch einmal zusätzlich dekodieren.
Daher ist der <tt class="docutils literal"><span class="pre">MoodbarProvider</span></tt> momentan eher als <em>Notbehelf</em> zu sehen.</p>
<p>Zudem ist die Geschwindigkeit der Audioanalyse eher dürftig. Geht das
Analysieren des RGB&ndash;Vektors an sich vergleichsweise schnell, so ist die
Generierung desselben zeitlich aufwendig. Bei MP3&ndash;enkodierten Dateien dauerst
dies, je nach Größe, bis zu 4 Sekunden. Die Dauer variiert dabei je nach Format.
FLAC&ndash;enkodierte Dateien brauchen oft lediglich die Hälfte dieser Zeit. In
beiden Fällen ist die Anwendung bei einer mehreren zehntausend Lieder
umfassenden Sammlung sehr aufwendig. Neben der Liedtextsuche ist dies der größte
Posten beim <em>Kaltstart</em>.</p>
<p><em>Vorteile sind hingegen:</em></p>
<ul class="simple">
<li><strong>Robustheit:</strong> Wie man in  sieht, ist das
Verfahren relativ umempfdindlich gegen verschieden Enkodierungen. Selbst Live
und Studioversionen zeigen gut vergleichbare Resultate (siehe Abb.
).</li>
<li><strong>Geringer Speicherverbrauch:</strong> Obwohl für die Implementierung die relativ
speicherhungrige Sprache Python benutzt wurde, nutzt der <tt class="docutils literal"><span class="pre">MoodbarProvider</span></tt>
lediglich etwa 540 Bytes pro Analysedatensatz. Da Python die Zählen &ndash;10 bis
255 im Speicher hält und der <tt class="docutils literal"><span class="pre">MoodbarProvider</span></tt> nur Zahlen in diesem Bereich
erzeugt, reichen hier 8 Byte für eine Referenz auf einen Integer aus.</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Der in der URL gezeigte <em>API Key</em> ist auf <em>libmunin</em> registriert. Er
sollte nicht für andere Zwecke verwendet werden.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><em>Anmerkung:</em> Die Idee entstand allerdings ohne Kenntnis von <em>beets</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Sollte <em>beets</em> je nach Python <span class="math">\(\ge 3.0\)</span> portiert werden, so wird
der Autor den <em>beets</em>&ndash;Autoren gern einen Patch zusenden.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-rst/6_learning/index"></span><div class="section" id="implizites-lernen-vom-nutzer">
<h2>6 Implizites Lernen vom Nutzer<a class="headerlink" href="#implizites-lernen-vom-nutzer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="generierung-von-regeln">
<h3>6.1 Generierung von Regeln<a class="headerlink" href="#generierung-von-regeln" title="Permalink to this headline">¶</a></h3>
<p>In vorangegangen Kapiteln wurde schon oft davon gesprochen, dass
<em>libmunin</em> den Nutzer <em>,,beobachtet&quot;</em>. Dies geschieht indem der
Anwendungsentwickler, die vom Nutzer gehörten Titel an <em>libmunin</em> zurückmeldet.</p>
<div class="section" id="finden-von-wiederkehrenden-mustern">
<h4>6.1.1 Finden von wiederkehrenden Mustern<a class="headerlink" href="#finden-von-wiederkehrenden-mustern" title="Permalink to this headline">¶</a></h4>
<p>Um eine <em>,,Warenkorbanalyse&quot;</em> durchzuführen braucht man erstmal <em>Warenkörbe</em>.
Die Entstehung dieser wurde bereits in der Projektarbeit betrachtet: Die
einzelnen Songs in der Historie werden zeitlich gruppiert und bei einer maximalen
Gruppengröße abgeschnitten.</p>
<p>Diese einzelnen Gruppen von Songs fungieren dann als <em>Warenkörbe.</em> Aus diesen
gilt es zuerst eine Menge an Songs (im Folgenden <em>Muster</em> <a class="footnote-reference" href="#f1" id="id1"><sup>1</sup></a> genannt) zu
finden, die jeweils oft zusammen in den einzelnen Warenkörben vorkommen. Der
<em>naive</em> Ansatz wäre für jede Kombination der Eingabesongs das Vorkommen jeder
Kombination im Warenkorb zu zählen. Wie man sich bereits denken kann, ist
hierfür der algorithmische Aufwand enorm, denn bereits bei einer Menge von
<span class="math">\(1000\)</span> unterschiedlichen Songs in der Historie müssten bereits
<span class="math">\(1000!\)</span> Kombinationen gebildet werden.</p>
<p>Für die Lösung dieses Problems gibt es einige etablierte Algorithmen.  Der
bekannteste ist vermutlich der <em>Apriori&ndash;Algorithmus</em> <a class="reference internal" href="rst/index.html#agrawal1993mining" id="id2">[1]</a>.
Statt alle Kombinationen zu betrachten, werden erst alle
<em>,,Einer&ndash;Kombinationen&quot;</em> gebildet und die ausgefiltert, welche einen zu
niedrigen <em>Support&ndash;Count</em> besitzen. Die Grenze legt man vorher fest. Der
<em>Support&ndash;Count</em> ist einfach die Anzahl der <em>Warenkörbe</em> in dem ein Song
vorkommt, geteilt durch die absolute Anzahl der Warenkörbe. Danach werden mit
den Verbliebenen 2er&ndash;Kombination gebildet, wieder gefiltert, dann die noch
relevanten 3er&ndash;Kombinationen und so weiter. Dadurch wird eine große Menge von
Kombinationen vermieden.</p>
<p>Seit einiger Zeit haben sich jedoch eine Gruppe effizienterer (und damit
einhergehend schwerer zu erklärender) Algorithmen etabliert. Dazu gehören der
FP&ndash;Growth <a class="reference internal" href="rst/index.html#han2000miningfpgrowth" id="id3">[6]</a>, Eclat <a class="reference internal" href="rst/index.html#eclat" id="id4">[13]</a>, sowie der
hier verwendete <tt class="docutils literal"><span class="pre">RELIM</span></tt>&ndash;Algorithmus <a class="reference internal" href="rst/index.html#relim" id="id5">[3]</a>.</p>
<div class="figure align-center" id="table-itemsets">
<center><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="9%" />
<col width="24%" />
<col width="9%" />
<col width="24%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kombination (1er)</th>
<th class="head">Anzahl</th>
<th class="head">Kombination (2er)</th>
<th class="head">Anzahl</th>
<th class="head">Kombination (3er)</th>
<th class="head">Anzahl</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>A</em></td>
<td>1 <span class="math">\(\times\)</span></td>
<td><em>A, B</em></td>
<td>1 <span class="math">\(\times\)</span></td>
<td><em>A, B, C</em></td>
<td>1 <span class="math">\(\times\)</span></td>
</tr>
<tr class="row-odd"><td><em>B</em></td>
<td>3 <span class="math">\(\times\)</span></td>
<td><em>B, C</em></td>
<td>3 <span class="math">\(\times\)</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><em>C</em></td>
<td>3 <span class="math">\(\times\)</span></td>
<td><em>C, A</em></td>
<td>1 <span class="math">\(\times\)</span></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="caption">Die Muster, welche aus den drei Warenkörben {{A, B, C} {B, B, C},
{C, C, B}} generiert worden sind.</p>
</center></div><p id="table-itemsets">In Tabelle  sehen wir ein Beispiel aus drei Warenkörben,
aus denen per Hand mit der naiven Herangehensweise alle möglichen Kombinationen
samt deren Support&ndash;Count aufgelistet worden sind.</p>
</div>
<div class="section" id="der-relim-algorithmus">
<h4>6.1.2 Der <tt class="docutils literal"><span class="pre">RELIM</span></tt>&ndash;Algorithmus<a class="headerlink" href="#der-relim-algorithmus" title="Permalink to this headline">¶</a></h4>
<p>Generell gilt FP&ndash;Growth als der <em>neue</em> Standard&ndash;Algorithmus, der laut mehrerer
Quellen andere Algorithmen wie Eclat und <tt class="docutils literal"><span class="pre">RELIM</span></tt> (<tt class="docutils literal"><span class="pre">RE</span></tt>&ndash;<em>cursive</em> <tt class="docutils literal"><span class="pre">ELIM</span></tt>&ndash;<em>ination</em>)
aussticht <a class="reference internal" href="rst/index.html#gyhorodi2004comparative" id="id6">[5]</a> <a class="reference internal" href="rst/index.html#santhosh2010implementation" id="id7">[10]</a>.</p>
<p>In diesem Fall wird trotzdem auf <tt class="docutils literal"><span class="pre">RELIM</span></tt> zurückgegriffen, da dieser für die
Zwecke des Autors ausreichend schnell ist und die Datenmenge nie mehr als wenige
tausend Songs übersteigen wird. Zudem gibt es mit dem Python&ndash;Paket <em>pymining</em>
(siehe <a class="reference internal" href="rst/index.html#pymining" id="id8">[Link&ndash;15]</a>) bereits eine freie, qualitativ relativ hochwertige
Implementierung, während es für FP&ndash;Growth nur qualitativ schlechte
Implementierungen zu geben scheint, oder welche, die nur für Python&ndash;Versionen
<span class="math">\(\leq 2.7\)</span> funktionieren.</p>
</div>
<div class="section" id="ableitung-von-regeln-aus-mustern">
<h4>6.1.3 Ableitung von Regeln aus Mustern<a class="headerlink" href="#ableitung-von-regeln-aus-mustern" title="Permalink to this headline">¶</a></h4>
<p>Hat man erstmal eine Gruppe von häufig zusammen auftretender
Song&ndash;Kombinationen, so können daraus Assoziationsregeln abgeleitet werden.
Dazu teilt man das Muster in alle möglichen verschiedenen, disjunkten Teilmengen
auf. Allerdings in maximal zwei Teilmengen.  Diese beiden Teilmengen nimmt man
als die beiden <em>Mengen</em> einer <a class="reference internal" href="rst/index.html#term-assoziationsregel"><em class="xref std std-term">Assoziationsregel</em></a> an und probt, mittels
verschiedener <em>Metriken</em>, wie zutreffend diese ist.</p>
<div class="figure align-center" id="table-rules">
<center><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="16%" />
<col width="17%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>Assoziationsregel</em></th>
<th class="head"><em>Support</em></th>
<th class="head"><em>Imbalance Ratio</em></th>
<th class="head"><em>Kulczynski</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(\left\{A\right\} \leftrightarrow \left\{B\right\}\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math">\(\left\{B\right\} \leftrightarrow \left\{C\right\}\)</span></td>
<td><span class="math">\(1.0\)</span></td>
<td><span class="math">\(0\)</span></td>
<td><span class="math">\(1\)</span></td>
</tr>
<tr class="row-even"><td><span class="math">\(\left\{C\right\} \leftrightarrow \left\{A\right\}\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
</tr>
<tr class="row-odd"><td> <span class="math">\(\left\{A\right\} \leftrightarrow \left\{B, C\right\}\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math">\(\left\{B\right\} \leftrightarrow \left\{A, C\right\}\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
<td><span class="math">\(0\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math">\(\left\{C\right\} \leftrightarrow \left\{A, B\right\}\)</span></td>
<td><span class="math">\(0.\overline{3}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
<td><span class="math">\(0.\overline{6}\)</span></td>
</tr>
</tbody>
</table>
<p class="caption">Mögliche Regeln die aus den 3 Warenkörben erstellt werden können.
Zusätzlich wird der dazugehörige Gesamt&ndash;Support&ndash;Count, sowie die
beiden Metriken Imbalance&ndash;Ratio und Kulczynski abgebildet.</p>
</center></div><p id="table-rules">Als Beispiel können wir wieder die Warenkörbe aus  nehmen.
Muster mit nur einem Song können nicht weiter aufgeteilt werden, daher müssen
diese nicht weiter betrachtet werden. Die 2er&ndash;Kombination sind leicht in zwei
Teilmengen aufzuteilen. Für die 3er&ndash;Kombinationen können mehrere möglichen
Teilmengen erstellt werden. Die einzelnen möglichen Regeln werden in
 aufgelistet.</p>
<p>Nicht jede Regel ist automatisch eine gute Regel. Das gängige Lehrbeispiel
hierbei ist eine Regel die besagt, dass <span class="math">\(60\%\)</span> aller <em>Basketballspieler</em>
zum Frühstück <em>Cornflakes</em> essen.  Der Anteil der Menschen die aber insgesamt
Cornflakes essen liegt bei <span class="math">\(70\%\)</span> &ndash;- daher ist die Eigenschaft
<em>,,Basketballspieler&quot;</em> sogar ein Gegenindiz für die Eigenschaft
<em>,,Cornflake&ndash;Esser&quot;</em>.</p>
<p>Um solche <em>falschen</em> Assoziationsregeln zu vermeiden, werden für jede Regel zwei
Metriken errechnet. Die von <em>libmunin</em> genutzten Metriken wurde dem Buch
<em>Datamining Concepts and Techniques</em> <a class="reference internal" href="rst/index.html#datamining-concepts-and-techniques" id="id9">[7]</a>
entnommen: Die <em>Kulczynski&ndash;Metrik</em> und der <em>Imbalance&ndash;Ratio</em>.</p>
<p>Die <em>Kulczynski&ndash;Metrik</em> drückt die <em>Güte</em> der Regel als eine reele Zahl im
Bereich <span class="math">\(\lbrack 0, 1\rbrack\)</span> aus, wobei <span class="math">\(1\)</span> die beste Wertung ist.
Grob ausgedrückt besagt die Metrik, wie zutreffend die Regel im Durchschnitt
ist. <tt class="docutils literal"><span class="pre">A</span></tt> und <tt class="docutils literal"><span class="pre">B</span></tt> sind im Folgenden die beiden Teilmengen der Regel:</p>
<div class="math">
\[Kulczynski(A, B) =  \frac{P(A \mid B) + P(B \mid A)}{2}\]</div>
<p><span class="math">\(P(A \vert B)\)</span> ist die bedingte Wahrscheinlichkeit und ist meist definiert
als:</p>
<div class="math">
\[P(A\mid B) = \frac{P(A\cap B)}{P(B)}\]</div>
<p>Da <span class="math">\(P(B)\)</span> gleichbedeutend mit dem <em>Support&ndash;Count</em> der rechten Seite der
Regel ist und <span class="math">\(P(A\cap B)\)</span> der <em>Support&ndash;Count</em> der gesamten Regel ist,
kann man schlussfolgern:</p>
<div class="math">
\[P(A\mid B) = \frac{support(A \cap B)}{support(B)}\]</div>
<p>Letzteres lässt sich relativ einfach berechnen. Setzt man das in die
ursprüngliche Gleichung ein, so wird klar wie sich die <em>Kulczynski&ndash;Metrik</em>
berechnen lässt:</p>
<div class="math">
\[Kulczynski(A, B) = \frac{1}{2} \times \left(\frac{support(A\cap B)}{support(B)} + \frac{support(A\cap B)}{support(A)}\right)\]</div>
<p>Der <em>Imbalance Ratio</em> gibt im Bereich <span class="math">\(\lbrack 0, 1\rbrack\)</span> an wie
gleichmäßig sich die Regeln anwenden lässt.  Hier ist der beste Wert die
<span class="math">\(0\)</span>.  Er ist gegeben durch:</p>
<div class="math">
\[ImbalanceRatio(A, B) = \frac{\vert support(A) - support(B)\vert}{support(A) + support(B) - support(A \cap B)}\]</div>
<p>Sollte die <em>Kulczynski&ndash;Metrik</em> kleiner als <span class="math">\(0.\overline{6}\)</span> sein oder der
<em>Imbalance&ndash;Ratio</em> größer als <span class="math">\(0.35\)</span>, so wird die Regel fallen gelassen.
Diese Grenzwerte worden, mehr oder minder willkürlich, nach einigen Tests
festgelegt.</p>
<p>Sollte die Regel <em>akzeptabel</em> sein, dann werden beide Metriken in eine
einzelne, leichter zu handhabendes <em>Rating&ndash;Metrik</em> verschmolzen:</p>
<div class="math">
\[Rating(A, B) = \left(1 - ImbalanceRatio(A, B)\right) \times Kulczynski(A, B)\]</div>
<p>Dieses <em>Rating</em> wird genutzt um die einzelnen Assoziationsregeln zu sortieren.</p>
</div>
</div>
<div class="section" id="anwendung-von-regeln">
<h3>6.2 Anwendung von Regeln<a class="headerlink" href="#anwendung-von-regeln" title="Permalink to this headline">¶</a></h3>
<p>Wie bereits unter <a class="reference internal" href="rst/index.html#ref-graphops-rules">4.2.2</a> erklärt, werden Assoziationsregel
als Navigationshilfe beim Traversieren genutzt.  Zu diesem Zwecke müssen die
entstandenen Regeln irgendwo sortiert abgelegt werden.  Diese Ablage ist der
<tt class="docutils literal"><span class="pre">RuleIndex</span></tt>. Beim Einfügen wird jeweils überprüft, ob die Maximalanzahl an
Regeln (momentan maximal <span class="math">\(1000\)</span>) übertroffen wird. Sollte dem so sein,
wird die älteste (ergo, zu erst eingefügte) Regel gelöscht um Platz zu machen.</p>
<p>Der Anwendungsentwickler kann mittels der <tt class="docutils literal"><span class="pre">lookup(song)</span></tt>&ndash;Methode eine Liste
von Regeln abfragen, die diesen Song in irgendeiner Weise betreffen. Um diese
Operation zu beschleunigen, wird intern eine Hashtabelle gehalten, mit dem Song
als Schlüssel und der entsprechende Regel&ndash;Liste als zugehöriger Wert.</p>
<p>Bei jeder Operation auf dem <tt class="docutils literal"><span class="pre">RuleIndex</span></tt> wird er automatisch bereinigt.
Dabei werden Regeln entfernt, die Songs erwähnen, welche nicht mehr in der
Historie vertreten sind.</p>
</div>
<div class="section" id="lernerfolg">
<h3>6.3 Lernerfolg<a class="headerlink" href="#lernerfolg" title="Permalink to this headline">¶</a></h3>
<p>Noch sind keine Aussagen darüber möglich wie <em>gut</em> die momentane Lernstrategie
funktioniert. Einerseits ist es schwer festzustellen was <em>gut</em> bedeutet,
andererseits wurde eine <em>libmunin&ndash;Session</em> noch nie lange genug benutzt,
um Aussagen über die Langzeitfunktionalität zu geben.</p>
<p>Daher ist die oben genannte Vorgehensweise als <em>,,Theorie&quot;</em> zu sehen, die sich
erst noch in der Praxis bewähren muss. Änderungen sind wahrscheinlich.</p>
<p>Zudem muss auch auf Seite der Implementierung noch ein Detail verbessert werden:
Momentan wird nur die Historie aufgezeichnet, wenn die Demonanwendung läuft. Da
die Anwendung lediglich eine Fernbedienung für den MPD ist, läuft diese nicht
die ganze Zeit über. Eine Abhilfe würde ein gepatchter MPD&ndash;Server schaffen, der
sich seine Historie merkt oder eine separater MPD&ndash;Client der nur dafür dient im
Hintergrund die Historie&ndash;Daten mitzuloggen.</p>
</div>
<div class="section" id="explizites-lernen">
<h3>6.4 Explizites Lernen<a class="headerlink" href="#explizites-lernen" title="Permalink to this headline">¶</a></h3>
<div class="figure compound align-center" id="fig-modify-moves">
<div style="width: 75%" class="subfigure align-center" id="fig-move-before">
<a class="reference internal image-reference" href="../../_images/big_move_before_edit.png"><img alt="Graph vor dem Vergeben eines hohen Ratings." src="../../_images/big_move_before_edit.png" style="width: 97%;" /></a>
<p class="caption">Vor dem Vergeben der Ratings.</p>
</div>
<div style="width: 75%" class="subfigure align-center" id="fig-move-after">
<a class="reference internal image-reference" href="../../_images/big_move_after_edit.png"><img alt="Graph nach dem Vergeben eines hohen Ratings" src="../../_images/big_move_after_edit.png" style="width: 97%;" /></a>
<p class="caption">Nach dem Vergeben der Ratings.</p>
</div>
<p class="caption">Vor und nach dem Vergeben von einem hohen Ratings an drei Lieder
(,,Rachsucht”, ,,Nagelfar”, ,,Meine Brille”, jeweils rot eingekreist).
Die dazugehörigen Alben sind in rötlich, grünlich und bläulich
hervorgehoben. Nach dem Vergeben sieht man, dass die entsprechenden Songs
sich von den einzelnen Albums&ndash;Cluster entfernt haben und Verbindungen zu
anderen Album bekommen haben. Zudem haben sich die beiden erstgenannten
Songs miteinander verbunden.</p>
</div><p id="fig-modify-moves">Neben dem <em>impliziten Lernen</em> gibt es auch den <em>,,nachträglich entdeckten&quot;</em>
Mechanismus des <em>expliziten Lernens</em>. Dieser wurde bereits in Kapitel
<a class="reference internal" href="rst/index.html#ref-graphop-insert">4.1.5</a> beleuchtet. Unter Abb.  soll
dies lediglich nochmal visualisiert werden. Die dort abgebildete <em>Verschiebung</em>
ist dadurch zu erklären, dass die <tt class="docutils literal"><span class="pre">insert</span></tt>&ndash;Operation meist einen anderen zum
Wiedereinfügen findet.</p>
<p>Durch Ändern des <em>Ratings</em> in der Demonanwendung können einzelne Knoten gezielt
im Graphen bewegt werden. Knoten mit ähnlichem Rating wandern näher zusammen und
stellen <em>,,Brücken&quot;</em> zu anderen Album&ndash;Clustern her. Man kann dieses <em>Feature</em>
einerseits dazu nutzen, um seine Favoriten nahe im Graphen zusammenzupacken,
andererseits, um unpassende Empfehlungen mit einem schlechten Rating
abzustrafen, was eine <tt class="docutils literal"><span class="pre">insert</span></tt>&ndash;Operation auf diesen Song zur Folge hätte.
Dadurch wird er möglicherweise an anderer Stelle besser eingepasst.</p>
<p>Der <em>,,Mechanismus&quot;</em> des <em>expliziten Lernens</em> ist relativ debattierbar und war
mehr ein Nebeneffekt der Entwicklung. Zukünftige Versionen könnten leichter
steuerbar und intuitiver verständliche Mechanismen anbieten.  Ein Ansatz wäre
der Weg, den <em>Intelligente Playlisten</em> bei vielen Music&ndash;Playern gehen: Der
Nutzer stellt Beziehungen zwischen Attributen und Werten her. Ein Attribut wäre
beispielsweise <tt class="docutils literal"><span class="pre">date</span></tt>, ein Wert <tt class="docutils literal"><span class="pre">2010</span></tt> und eine Beziehung <span class="math">\(\ge\)</span>.
Weitere Beziehungen wären <span class="math">\(=\)</span>, <span class="math">\(\neq\)</span>, <span class="math">\(&lt;\)</span> oder <span class="math">\(\le\)</span>.</p>
<p>Mit all den unterschiedlichen Attributen wären dann automatisch erstellte
Playlisten wie  <em>,,Favouriten&quot;</em> ( <tt class="docutils literal"><span class="pre">rating</span> <span class="pre">&gt;</span> <span class="pre">3</span></tt> ), <em>,,Ungehörte&quot;</em> ( <tt class="docutils literal"><span class="pre">Playcount</span>
<span class="pre">=</span> <span class="pre">0</span></tt> ) und <em>,,Neu Hinzugefügte&quot;</em> ( <tt class="docutils literal"><span class="pre">date</span> <span class="pre">&gt;</span> <span class="pre">(today</span> <span class="pre">-</span> <span class="pre">7</span> <span class="pre">days)</span></tt> ) möglich.
Für letzere könnten hilfreiche Konstanten wie <tt class="docutils literal"><span class="pre">today</span></tt> eingeführt werden.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In englischer Lektüre werden die <em>Wiederkehrenden Muster</em> als <em>Frequent
Itemsets</em> bezeichnet.</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-rst/7_outro/index"></span><div class="section" id="ausblick">
<h2>7 Ausblick<a class="headerlink" href="#ausblick" title="Permalink to this headline">¶</a></h2>
<div class="section" id="verbesserung-der-algorithmik">
<h3>7.1 Verbesserung der Algorithmik<a class="headerlink" href="#verbesserung-der-algorithmik" title="Permalink to this headline">¶</a></h3>
<p>Im Folgenden werden einige Ideen für mögliche Weiterenwicklungen an
den vorgestellten Algorithmen gegeben.  Einige davon sind vergleichsweise
einfach umsetzbar. Andere könnten die Grundlage für fortführende Arbeiten sein.</p>
<div class="section" id="audioanalyse">
<h4>7.1.1 Audioanalyse<a class="headerlink" href="#audioanalyse" title="Permalink to this headline">¶</a></h4>
<p>Wie bereits erwähnt ist <em>libmunin's</em> momentane <em>,,Audioanalyse&quot;</em> eher simpler
Natur.  Als konkrete Vorlage für eine verbesserte <em>Audioanalyse</em> könnte <em>Mirage</em>
dienen. In seiner Arbeit stellt der Mirage&ndash;Autor <a class="reference internal" href="rst/index.html#schnitzer2007high" id="id1">[11]</a>
Dominik Schnitzer einige Herangehensweise zum performanten Vergleich von
Audiodaten vor.</p>
<p>Angesichts der hohen Entwicklungsgeschwindigkeit in der Informatik und dem
<em>,,hohem&quot;</em> Alter der Arbeit (<span class="math">\(2007\)</span>) sollte allerdings beachtet werden,
dass es bereits neuere Methoden geben könnte. Beispielsweise arbeitet Schnitzer
<em>nur</em> mit MP3&ndash;Audiodaten <a class="footnote-reference" href="#f1" id="id2"><sup>1</sup></a>. Eine Abhilfe wäre die relativ neue Bibliothek
<em>libaubio</em>, die von <em>Paul Brossier</em> <a class="reference internal" href="rst/index.html#aubio" id="id3">[Link&ndash;16]</a> entwickelt wird.</p>
<p><em>Aubio</em> könnte folgendes leisten:</p>
<ul class="simple">
<li>Exaktere Bestimmung des <em>BPM&ndash;Wertes</em>. Beziehungsweise könnte man auch einen
Verlauf des <em>BPM&ndash;Wertes</em> über das Musikstück aufzeichnen um exaktere
Vergleiche ziehen zu können.</li>
<li><em>Onset&ndash;Detection</em>, also das Erkennen einzelner Noten beziehungsweise
<em>Sounds</em>.</li>
<li>Eine direkte Möglichkeit die Stimmung in einem Lied zu analysieren wird
momentan zwar noch nicht geboten, aber die dazu benötigten Informationen, wie
die Erkennung der Tonlage zu einem bestimmten Zeitpunkt werden angeboten.
Die technischen Details dazu werden in <a class="reference internal" href="rst/index.html#schnitzer2007high" id="id4">[11]</a> diskutiert.</li>
</ul>
<p>Die Bibliothek selber ist in <cite>C</cite> geschrieben, bietet aber eine komfortable
Python&ndash;Schnitstelle.</p>
<p>Eine weiter Idee wäre der Versuch, möglichst intelligent, reine Sprachdateien
(wie <em>Hörbücher),</em> Instrumental&ndash;Lieder ohne Stimme (wie <em>Intros)</em> und normale
Musik zu unterscheiden. Oft werden zu bestimmten Titeln unpassenderweise
<em>Intros</em> vorgeschlagen, die man für gewöhnlich nur hören möchte, wenn man das
gesamte Album von vorn bis hinten anhört. Auch hier wäre ein Einsatz von <em>Aubio</em>
denkbar.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Mirage verlässt sich dabei auf bestimmte Eigenschaften von MP3
um die Daten schneller in seine interne Datenrepräsentation zu
konvertieren.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="andere-provider">
<h4>7.1.2 Andere Provider<a class="headerlink" href="#andere-provider" title="Permalink to this headline">¶</a></h4>
<p>Wie man im Playlistenvergleich unter <a class="reference internal" href="rst/index.html#ref-playlist-compare">3.3</a> gesehen hat,
ist momentan der Vergleich der Metadaten die Stärke von <em>libmunin</em>. Diese
Fähigkeit könnte noch weiter ausgebaut werden, indem die Sprache der einzelnen
Titel (denn nicht immer sind Liedtexte vorhanden) erkannt wird. Dann könnte man
mittels eines Thesaurus synonyme Titel finden. Für Python existiert mit
<em>TextBlob</em> <a class="reference internal" href="rst/index.html#textblob" id="id5">[Link&ndash;17]</a> hierfür eine passende Bibliothek. <br /> Kommt
beispielsweise in einem Liedtitel das Wort <em>,,Sofa&quot;</em> vor, so könnte ein Titel
mit dem synonymen Wort ,,Couch&quot; darin vorgeschlagen werden.  Auch Taxonomien,
also ähnliche <em>Klassifikationen</em>, sind denkbar. Man denke hier an einem Lied
welches das Wort <em>,,Katze&quot;</em> enthält und ein anderes das <em>,,Tier&quot;</em> beinhaltet.
<br /> In der momentanen Implementierung wird jedes Wort im Titel auf seinen
Wortstamm gebracht und mittels der Levenshtein&ndash;Distanzfunktion verglichen.
Diese Lösung war zwar leicht zu implementiere, ist aber relativ teuer und
ungenau.</p>
<p>Auch interessant zu sehen wäre es, ob die Länge der einzelnen Stücke in
irgendeiner Form mit der Ähnlichkeit korrelieren. Hier müssten statistische
Auswertungen gemacht werden, um diesen Zusammenhang zu überprüfen. Falls sich
ein Zusammenhang zeigen sollte, ließe sich eine einfache
<tt class="docutils literal"><span class="pre">DurationDistanceFunction</span></tt> schreiben welche ähnlich lange Stücke gut bewertet.</p>
</div>
<div class="section" id="empfehlungen">
<h4>7.1.3 Empfehlungen<a class="headerlink" href="#empfehlungen" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="fig-traverse-areas">
<a class="reference internal image-reference" href="../../_images/traverse_areas.svg"><img alt="Schematische Darstellung der idealen Traversierungsreihenfolge" src="../../_images/traverse_areas.svg" width="75%" /></a>
<p class="caption">Schematische Darstellung der idealen Traversierungsreihenfolge.
Die roten Knoten stelln die Seedsongs dar, die gelben und orangen Knoten sind
direkte Nachbarn. Die grünen Knoten sind ,,irgendwo” dazwischen. Die
Traversierungsreihenfolge sollte hier sein: Orange, Gelb, Grün.</p>
</div>
<p>Oft kommt es vor, dass es mehr als einen <em>Seedsong</em> gibt. Die momentane, simple
Herangehensweise, ist für jeden einen Iterator zu erstellen und die einzelnen
Iteratoren im Reißverchlussverfahren zu verweben. Das ist duchaus valide, wenn
man annimmt, dass die <em>Seedsongs</em> im Graphen verteilt und alle gleich
wichtig sind. Oft ballen sich Seedsongs aber auf einem bestimmten Gebiet.
Schematisch ist das in Abb.  dargestellt. Besitzen zwei
<em>Seedsongs</em> gemeinsame Nachbarn, dann sollten diese zuerst besucht werden.</p>
<p>Auch ist das Ausgabeformat von <em>libmunin</em> noch auf einzelne Songs als
<em>Empfehlung</em> beschränkt. Nicht selten möchte man jedoch eine allgemeinere
Auskunft wie <em>,,Gib mir einen ähnlichen Künstler/Album/Genre&quot;</em>. Momentan wäre
dies nur durch Auslesen der jeweiligen Attribute aus den einzelnen Empfehlungen
möglich. Allerdings könnten hier von <em>libmunin</em> optimierte
Traversierungsstrategien implementiert werden.</p>
</div>
</div>
<div class="section" id="erweiterungen">
<h3>7.2 Erweiterungen<a class="headerlink" href="#erweiterungen" title="Permalink to this headline">¶</a></h3>
<p>Die verwendeten Metadaten könnten ebenfalls erweitert werden. Für die
Ähnlichkeit sind unter Umständen auch Attribute wie der <em>Producer</em>, die
<em>Band&ndash;Mitglieder</em> oder die <em>Herkunft der Band</em> relevant. Einfache Beispiele
hier wären ,,Wer Songs von den Ärzten hört, der hört vermutlich auch gern Farin
Urlaub Racing Team&quot; &ndash;- natürlich unter der Annahme, dass derselbe Künstler auch
immer ähnliche Musik produziert.</p>
<p>Was das Lernen von <em>libmunin</em> angeht, so sollten auch ,,negative Impulse&quot;
behandelt werden. Wird beispielsweise ein bestimmtes Lied oder gar Künstler sehr
oft geskippt (also übersprungen), könnte <em>libmunin</em> dies berücksichtigen indem
es bei der Traversierung diesen Knoten ,,umgeht&quot;. Alternativ wäre auch ein
nachträgliches Filtern der entsprechenden Lieder möglich.</p>
<p>Allgemein wäre auch eine Erweiterung von Assoziationsregeln denkbar. Momentan
verbindet eine Regel immer zwei Mengen von Songs miteinander. Alternativ könnten
aber auch verschiedene Genres, Künstler oder auch Alben in einer
Regel miteinander verbunden werden. Das Erstellen solcher  Regeln wäre relativ
einfach mit der existierenden Technik. Was problematisch ist, ist diese neuen
Regeln als <em>Traversierungshilfe</em> zu nutzen.</p>
<p>Ein weiterer Punkt den man beim Lernen verbessern könnte, sind die Gewichtungen,
die manuell für jedes Attribut festgelegt werden. Man könnte den Nutzer
beobachten und sehen nach welchen Attribut er bevorzugt seine Lieder auswählt
(beispielsweise nach Genre). Das entsprechende Attribut könnte dann höher
gewertet werden.</p>
<p>Auch wäre ein zusätzliches Modul möglich, das <em>libmunin</em> nutzt, um Suchanfragen
basierend auf natürlicher Sprache zu ermöglichen. So könnten Anfragen wie
<em>,,Happy Indie Pop&quot;</em> aufgelöst werden. Im Beispiel würde sich <em>Happy</em> auf die
Stimmunng beziehen, <em>Pop</em> auf das Genre und <em>Indie</em> auf einen
Independet&ndash;Künstler. Letztere Information könnte man aus der Künstlerbiografie
extrahieren. Die Biografie kann automatisch von Tools wie <em>libglyr</em>
besorgt werden oder man greift alternativ auf Amazon&ndash;Reviews zurück. So
gesehen bietet sich hier ein Erweiterungspotenzial in Richtung
<em>,,Social&ndash;based&ndash;Recommendations&quot;</em>. Also man nutzt das Wissen von vielen
Menschen um bestimmte Attribute zu bestimmen, anstatt diese mithilfe von Metriken
zu bestimmen.
Die eigentliche Schwierigkeite bestünde aber darin, die einzelnen Wörter
bestimmten Attributen zuzuordnen.  Dies wäre jedenfalls ein spannendes Thema für
eine Folgearbeit.  Diese Idee basiert auf der Musiksuchmaschine von <em>Peter
Knees</em> <a class="reference internal" href="rst/index.html#knees2007music" id="id6">[8]</a>.</p>
</div>
<div class="section" id="fazit">
<h3>7.3 Fazit<a class="headerlink" href="#fazit" title="Permalink to this headline">¶</a></h3>
<p>Momentan ist <em>libmunin</em> vor allem eine Spielwiese für verschiedene Ideen rund um
die Frage, wie man einem Computer die Ähnlichkeit von zwei Musikstücken
feststellen lässt. Trotzdem erstellt <em>libmunin</em> selbst als Prototyp in seiner
Standardeinstellung bereits durchaus nützliche Playlisten. Aufgrund der relativ
kurzen Implementierungszeit für ein solches System, von etwas mehr als 3
Monaten, ist dies nach Meinung des Autors durchaus als Erfolg zu werten.</p>
<p>Die größte Schwäche ist aus Sicht des Autors der langsame Kaltstart, der einen
produktiven Einsatz der Bibliothek verhindert. In punkto Weiterentwicklung,
sollte dies die höchstpriosierte Aufgabe sein.</p>
<p>Die Neuerung dieser Arbeit ist weniger die vorgestellte Algorithmik &ndash;- der
allergrößte Teil existiert natürlich bereits in ähnlicher Form &ndash;- sondern, das
diese Funktionalität erstmals in einer allgemein nutzbaren, freien Bibliothek
vorhanden ist.</p>
</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">orphan:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p><strong>Abkürzungsverzeichnis</strong></p>
<div class="figure align-center">
<center><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head align-top">Abkürzung</th>
<th class="head align-top">Bedeutung</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td class="align-top">API</td>
<td class="align-top"><em>Application Programming Interface</em></td>
</tr>
<tr class="row-odd"><td class="align-top">BPM</td>
<td class="align-top"><em>Beats per Minute</em></td>
</tr>
<tr class="row-even"><td class="align-top">FAQ</td>
<td class="align-top"><em>Frequently Asked Questions</em></td>
</tr>
</tbody>
</table>
</center></div><div class="toctree-wrapper compound">
<span id="document-rst/appendix"></span><div class="section" id="bilder-des-song-graphen">
<h2>Bilder des Song&ndash;Graphen<a class="headerlink" href="#bilder-des-song-graphen" title="Permalink to this headline">¶</a></h2>
<div class="section" id="allgemeine-hinweise">
<h3>Allgemeine Hinweise<a class="headerlink" href="#allgemeine-hinweise" title="Permalink to this headline">¶</a></h3>
<p>Folgende visuelle Aspekte sind mit Informationen besetzt:</p>
<ul class="simple">
<li><em>Kantenfarbe:</em> Rote Farbe indiziert eine hohe Distanz. Grün eine mittlere
Distanz (etwa <span class="math">\(0.5\)</span>). Blau bis violett eine gute bis sehr gute
(<span class="math">\(0.1\)</span> bis <span class="math">\(0.0\)</span>). Rote Kanten sieht man selten, da in den meisten
Fällen immer ein guter Nachbar gefunden werden kann.</li>
<li><em>Kantendicke:</em> Zur optischen Untermalung variiert die Dicke der Kanten je nach
Distanz. Hohe Distanzen bekommen eine dünnere Kante.</li>
<li><em>Knotenfarbe:</em> Zeigt grob die Zentralität des Knoten an. Bietet lediglich eine
optische Navigationshilfe um auf Cluster hinzuweisen.</li>
<li>Der visuelle Abstand zwischen zwei Knoten hat <em>keine</em> Aussagekraft, auch wenn
ähnliche Knoten oft nah beieinander liegen.</li>
</ul>
<p>Die Abbildungen  bis 
und  bis  zeigen den
Aufbau des Graphen anhand von linearen und pseudozufälligen generierten
Testdaten mit jeweils 100, beziehungsweise <span class="math">\(200\)</span> Knoten.  Abbildung
 zeigt einen realen, praktischen Graphen mittlerer Größe
mit <span class="math">\(666\)</span> Knoten. Die Liedtitel wurden jeweils an die Knoten geschrieben.</p>
<p>Bei den linearen Testdaten werden die Zahlen von <span class="math">\(1\)</span> bis <span class="math">\(100\)</span>
aufsteigend jedem neuen Knoten gegeben. Das Resultat sollte im optimalen Fall
daher eine Kette von Knoten zeigen, deren Knotennummer von einem Ende zum
Anderen immer weiter steigt.  Die pseudozufälligen Testdaten mischen die
erwähnten linearen Daten mit zusätzlichen zufällig erscheinenden Daten gleicher
Anzahl.  Diese sind zum größten Teil auf den Bereich 25&ndash;75 aufgeteilt. Es
sollte ein Graph entstehen der ähnlich linear ist, aber in der Mitte eine
<em>,,Verdichtung&quot;</em> aufweist.  Beides sind Testdaten, die häufig zum Testen von
<em>libmunin</em> genutzt worden, da sie spezielle Extremfälle gut testen.</p>
</div>
<div class="section" id="plotting-der-graphen">
<h3>Plotting der Graphen<a class="headerlink" href="#plotting-der-graphen" title="Permalink to this headline">¶</a></h3>
<p>Alle Graphen in diesem Teil des Anhangs sind mithilfe des freien Python
Graphenframeworks <tt class="docutils literal"><span class="pre">igraph</span></tt> <a class="reference internal" href="rst/index.html#igraph" id="id1">[Link&ndash;18]</a> entstanden. Als Zeichenbibliothek
nutzt <tt class="docutils literal"><span class="pre">igraph</span></tt> die freie 2D Zeichenbibliothek <tt class="docutils literal"><span class="pre">cairo</span></tt> <a class="reference internal" href="rst/index.html#cairo" id="id2">[Link&ndash;19]</a>.  Der
verwendete Layouting&ndash;Algorithmus ist <em>,,Fruchtermann&ndash;Reingold&quot;</em>.</p>
<div class="figure compound align-center" id="fig-graph-linear">
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-basic">
<a class="reference internal image-reference" href="../../_images/graph_linear_basic.png"><img alt="Nur mit ``sliding_window`` behandelte Eingabe" src="../../_images/graph_linear_basic.png" style="width: 100%;" /></a>
<p class="caption">Nur mit <tt class="docutils literal"><span class="pre">sliding_window</span></tt> behandelte Eingabe.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-all">
<a class="reference internal image-reference" href="../../_images/graph_linear_all.png"><img alt="Zusätzlich mit dem ``centering_window`` und ``anti_centering_window`` behandelt" src="../../_images/graph_linear_all.png" style="width: 100%;" /></a>
<p class="caption">Zusätzlich mit dem <tt class="docutils literal"><span class="pre">centering_window</span></tt> und <tt class="docutils literal"><span class="pre">anti_centering_window</span></tt> behandelt.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-refine">
<a class="reference internal image-reference" href="../../_images/graph_linear_refine.png"><img alt="Zusätzliche Verfeinerungsphase" src="../../_images/graph_linear_refine.png" style="width: 100%;" /></a>
<p class="caption">Zusätzliche Verfeinerungsphase.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-stupid">
<a class="reference internal image-reference" href="../../_images/graph_linear_stupid.png"><img alt="Mittels ``rebuild_stupid`` generierter Vergleichsgraph" src="../../_images/graph_linear_stupid.png" style="width: 100%;" /></a>
<p class="caption">Mittels <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt> generierter Vergleichsgraph.</p>
</div>
<p class="caption">Verschiedene Stufen beim Aufbau eines Graphen aus linearen Testdaten. Die
Testdaten bestehen aus den Integern 1 bis 100.  Erwartet wird dabei als
Ausgabe eine lineare Kette von Knoten, wobei jeder Knoten ca. 7 Nachbarn
haben sollte.</p>
<span class="target" id="fig-graph-linear"></span></div><div class="figure align-center" id="fig-graph-euler-basic">
<a class="reference internal image-reference" href="../../_images/graph_euler_basic.png"><img alt="Graph aus Zufallsdaten nach erster Basisiteration" src="../../_images/graph_euler_basic.png" style="width: 100%;" /></a>
<p class="caption">Graph aus Zufallsdaten nach erster Basisiteration.</p>
</div>
<div class="figure align-center" id="fig-graph-euler-all">
<a class="reference internal image-reference" href="../../_images/graph_euler_all.png"><img alt="Graph aus Zufallsdaten nach allen Basisiterationen" src="../../_images/graph_euler_all.png" style="width: 100%;" /></a>
<p class="caption">Graph aus Zufallsdaten nach allen Basisiterationen.</p>
</div>
<div class="figure align-center" id="fig-graph-euler-refine">
<a class="reference internal image-reference" href="../../_images/graph_euler_refine.png"><img alt="Graph aus Zufallsdaten nach einem Verfeinerungsschritt" src="../../_images/graph_euler_refine.png" style="width: 100%;" /></a>
<p class="caption">Graph aus Zufallsdaten nach einem Verfeinerungsschritt.</p>
</div>
<div class="figure align-center" id="fig-graph-euler-stupid">
<a class="reference internal image-reference" href="../../_images/graph_euler_stupid.png"><img alt="Der ,,korrekte“, mittels rebuild_stupid erstellte Graph" src="../../_images/graph_euler_stupid.png" style="width: 100%;" /></a>
<p class="caption">Der ,,korrekte“, mittels rebuild_stupid erstellte Graph.</p>
</div>
<div class="figure align-center" id="fig-graph-full">
<a class="reference internal image-reference" href="../../_images/full_graph_small.png"><img alt="Vollständiger Graph aus 666 Knoten (aus der Demonanwendung)" src="../../_images/full_graph_small.png" style="width: 70%;" /></a>
<p class="caption">Auschnitt aus dem vollständigen Graph, der hinter den Empfehlungen der
Demonanwendungen steckt. Auf der beiliegenden CD ist der vollständige Graph
in A0 Größe enthalten.</p>
</div>
</div>
</div>
<div class="section" id="bilder-des-genregraphen">
<span id="genre-graph-vis"></span><h2>Bilder des Genregraphen<a class="headerlink" href="#bilder-des-genregraphen" title="Permalink to this headline">¶</a></h2>
<p>Der Vollständigkeit halber wird hier auch eine Visualisierung des Genre&ndash;Graphen
gezeigt. Daraus kann man zwar keine <em>,,neuen Erkenntnisse&quot;</em> ziehen, doch kann er
in der weniger detaillierten Version zumindest als Überblick über die einzelnen
Genres dienen. Die detailliertere Version führt einem vor Auge wieviel einzelne
Musikgenres mit der Zeit entstanden sind.  Die Graphen wurden mit dem freien
Graphenvisualisierungspaket <tt class="docutils literal"><span class="pre">Graphviz</span></tt> <a class="reference internal" href="rst/index.html#graphviz" id="id3">[Link&ndash;20]</a> generiert. Das
Vorgehen soll hier dokumentiert werden.</p>
<p>Folgendes erstellt die <tt class="docutils literal"><span class="pre">Graphviz</span></tt>&ndash;Eingabedatei.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">pwd</span>
~/dev/libmunin
<span class="nv">$ </span><span class="nb">export </span><span class="nv">PYTHONPATH</span><span class="o">=</span><span class="nv">$PYTHONPATH</span>:.
<span class="nv">$ </span>python <span class="s2">&quot;munin/provider/genre.py&quot;</span> --cli --plot 0.0  <span class="c"># Detailstufe: 0.0 = max.</span>
<span class="nv">$ </span>head -n8 <span class="s2">&quot;/tmp/genre.graph&quot;</span>
  graph <span class="o">{</span>
      <span class="nv">overlap</span><span class="o">=</span>prism3000; <span class="nv">overlap_scale</span><span class="o">=</span>-7; <span class="nv">splines</span><span class="o">=</span>curved
      edge <span class="o">[</span><span class="nv">color</span><span class="o">=</span><span class="s2">&quot;#666666&quot;</span><span class="o">]</span>
      node <span class="o">[</span><span class="nv">shape</span><span class="o">=</span><span class="s2">&quot;none&quot;</span>, <span class="nv">style</span><span class="o">=</span><span class="s2">&quot;rounded, filled&quot;</span>, <span class="nv">fillcolor</span><span class="o">=</span><span class="s2">&quot;...&quot;</span><span class="o">]</span>
      <span class="s2">&quot;music&quot;</span> -- <span class="s2">&quot;rock&quot;</span>
      <span class="s2">&quot;music&quot;</span> -- <span class="s2">&quot;pop&quot;</span>
      // ...
  <span class="o">}</span>
</pre></div>
</div>
<p>Daraus kann dann mittels <tt class="docutils literal"><span class="pre">Graphviz</span></tt>&ndash;Bordmitteln den Graphen in verschiedenen
Formaten rendern. Hier die Prozedur für ein <em>PDF</em>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>sfdp /tmp/genre.graph           | <span class="se">\ </span> <span class="c"># Layoutting der einzelnen Nodes.</span>
  gvmap -e                        | <span class="se">\ </span> <span class="c"># Einzeichnen der &quot;Länderflächen&quot;.</span>
  neato                             <span class="se">\ </span> <span class="c"># Eigentliches Zeichnen.</span>
     -Ecolor<span class="o">=</span><span class="s2">&quot;#55555555&quot;</span>            <span class="se">\ </span> <span class="c"># Farbe der Kanten.</span>
     -Nfontname<span class="o">=</span><span class="s2">&quot;TeX Gyre Adventor&quot;</span> <span class="se">\ </span> <span class="c"># Font für die Nodelabels.</span>
     -Tpdf                          <span class="se">\ </span> <span class="c"># Ausgabeformat.</span>
  &gt; graph.pdf                          <span class="c"># Ausgabedatei.</span>
<span class="nv">$ </span>pdf-viewer graph.pdf                 <span class="c"># Fertiges Bild.</span>
</pre></div>
</div>
<p><em>Anmerkung:</em> Die einzelnen <em>,,Länder&quot;</em> im Graphen dienen lediglich der optischen
Trennung. Die Farbsättigung der Knoten und die verwendete Größe der Schrift
weist auf die Menge der Kinder hin, die der Knoten hat. Je weiter weg der Knoten
vom Wurzelknoten entfernt ist, desto oranger wird er (von rot beginnend).</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_big.svg"><img alt="Übersicht über alle 1876 Musikgenres. (Detailstufe: 0.0)" src="../../_images/genre_graph_big.svg" width="89%" /></a>
<p class="caption">Übersicht über alle 1876 Musikgenres. (Detailstufe: 0.0)</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_mid.svg"><img alt="Übersicht über die gebräuchlichsten Musikgenres. (Detailstufe: 0.1)" src="../../_images/genre_graph_mid.svg" width="95%" /></a>
<p class="caption">Übersicht über die gebräuchlichsten Musikgenres. (Detailstufe: 0.1)</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_min.svg"><img alt="Übersicht über die wichtisten Musikgenres. (Detailstufe: 0.5)" src="../../_images/genre_graph_min.svg" width="100%" /></a>
<p class="caption">Übersicht über die wichtisten Musikgenres. (Detailstufe: 0.5)
Als ,,wichtig” gelten dabei Genres, die viele Untergenres hervorgebracht
haben.</p>
</div>
</div>
<div class="section" id="medien">
<h2>Medien<a class="headerlink" href="#medien" title="Permalink to this headline">¶</a></h2>
<p>Der Vollständigkeit halber werden hier noch die für <em>libmunin</em> erstellten Logos
abgedruckt. Abbildung  dient dabei eher als Logo für eigene
Zwecke, während das <em>Emblem</em> unter  von
Anwendungsentwicklern genutzt werden kann, um auf den Gebrauch von <em>libmunin</em> in
ihren Anwendungen hinzuweisen.</p>
<p>Die Grafiken wurde mit dem freien Vektorzeichenprogramm <tt class="docutils literal"><span class="pre">Inkscape</span></tt>
<a class="reference internal" href="rst/index.html#inkscape" id="id4">[Link&ndash;21]</a> erstellt und können auf der API&ndash;Dokumentation runtergeladen
werden: <a class="reference internal" href="rst/index.html#logos" id="id5">[Link&ndash;22]</a>.</p>
<div class="figure compound align-center" id="fig-logos">
<div style="width: 100%" class="subfigure align-center" id="fig-logo">
<a class="reference internal image-reference" href="../../_images/logo.svg"><img alt="Logo im quadratischen Format" src="../../_images/logo.svg" width="40%" /></a>
<p class="caption">Logo im quadratischen Format.</p>
</div>
<div style="width: 100%" class="subfigure align-center" id="fig-logo-emblem">
<a class="reference internal image-reference" href="../../_images/logo_emblem.svg"><img alt="Logo im breiten Format." src="../../_images/logo_emblem.svg" width="80%" /></a>
<p class="caption">Logo im breiten Format.</p>
</div>
<p class="caption">Logos für libmunin. Der dargestellte Vogel stellt Odin's Rabe ,,Munin“ dar.</p>
<span class="target" id="fig-logos"></span></div></div>
<span id="document-rst/zzz_bibliography"></span><div class="section" id="bibliographie">
<h2>Bibliographie<a class="headerlink" href="#bibliographie" title="Permalink to this headline">¶</a></h2>
</div>
<p id="bibtex-bibliography-rst/zzz_bibliography-0"><table class="docutils citation" frame="void" id="agrawal1993mining" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Rakesh Agrawal, Tomasz Imieliński, and Arun Swami. Mining association rules between sets of items in large databases. In <em>ACM SIGMOD Record</em>, volume 22, 207–216. ACM, 1993.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="berry2010text" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Michael&nbsp;W Berry and Jacob Kogan. <em>Text mining: applications and theory</em>. John Wiley &amp; Sons, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="relim" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Christian Borgelt. Keeping things simple: finding frequent item sets by recursive elimination. In <em>Proceedings of the 1st international workshop on open source data mining: frequent pattern mining implementations</em>, 66–70. ACM, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="brill2000improved" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Eric Brill and Robert&nbsp;C Moore. An improved error model for noisy channel spelling correction. In <em>Proceedings of the 38th Annual Meeting on Association for Computational Linguistics</em>, 286–293. Association for Computational Linguistics, 2000.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gyhorodi2004comparative" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>Cornelia Győrödi, Robert Győrödi, and Stefan Holban. A comparative study of association rules mining algorithms. In <em>SACI 2004, 1st Romanian-Hungarian Joint Symposium on Applied Computational Intelligence</em>, 213–222. 2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="han2000miningfpgrowth" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>Jiawei Han, Jian Pei, and Yiwen Yin. Mining frequent patterns without candidate generation. In <em>ACM SIGMOD Record</em>, volume 29, 1–12. ACM, 2000.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="datamining-concepts-and-techniques" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td>Jian&nbsp;Pei Jiawei&nbsp;Han, Micheline&nbsp;Kamber. Datamining - concepts and techniques, (3rd edition). In <em>Datamining - Concepts and Techniques</em>, 268–271. 2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="knees2007music" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td>Peter Knees, Tim Pohle, Markus Schedl, and Gerhard Widmer. A music search engine built upon audio-based and web-based similarity measures. In <em>Proceedings of the 30th annual international ACM SIGIR conference on Research and development in information retrieval</em>, 447–454. ACM, 2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="porter2001snowball" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td>Martin&nbsp;F Porter. Snowball: a language for stemming algorithms. 2001.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="santhosh2010implementation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>B&nbsp;Santhosh&nbsp;Kumar and KV&nbsp;Rukmani. Implementation of web usage mining using apriori and fp growth algorithms. <em>International Journal of Advanced Networking &amp; Applications</em>, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="schnitzer2007high" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td>Dominik Schnitzer. High-performance music similarity computation and automatic playlist generation. 2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wood2005techniques" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td>Gavin Wood and Simon O'Keefe. On techniques for content-based visual annotation to aid intra-track music navigation. In <em>ISMIR</em>, 58–65. 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="eclat" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[13]</td><td>Mohammed&nbsp;Javeed Zaki, Srinivasan Parthasarathy, Mitsunori Ogihara, Wei Li, and others. New algorithms for fast discovery of association rules. In <em>KDD</em>, volume 97, 283–286. 1997.</td></tr>
</tbody>
</table>
</p>
<div class="section" id="weblink-verzeichnis">
<h2>Weblink Verzeichnis<a class="headerlink" href="#weblink-verzeichnis" title="Permalink to this headline">¶</a></h2>
</div>
<p id="bibtex-bibliography-rst/zzz_bibliography-1"><table class="docutils citation" frame="void" id="picard" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;1]</td><td><span><a class="reference external" href="http://musicbrainz.org/doc/MusicBrainz_Picard">http://musicbrainz.org/doc/MusicBrainz_Picard</a></span>. [Stand: 15.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="a3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;2]</td><td><span><a class="reference external" href="http://musicbrainz.org/">http://musicbrainz.org/</a></span>. [Stand: 11.2.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wiki-fusion" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;3]</td><td><span><a class="reference external" href="http://de.wikipedia.org/wiki/Hierarchische_Clusteranalyse">http://de.wikipedia.org/wiki/Hierarchische_Clusteranalyse</a></span>. [Stand 12.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bidict" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;4]</td><td><span><a class="reference external" href="https://pypi.python.org/pypi/bidict">https://pypi.python.org/pypi/bidict</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="nt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;5]</td><td><span><a class="reference external" href="http://www.last.fm">http://www.last.fm</a></span>. [Stand: 11.2.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="discogs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;6]</td><td><span><a class="reference external" href="http://www.discogs.com">http://www.discogs.com</a></span>. [Stand: 11.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pyxdameraulevenshtein" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;7]</td><td><span><a class="reference external" href="https://github.com/gfairchild/pyxDamerauLevenshtein">https://github.com/gfairchild/pyxDamerauLevenshtein</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="brainz-faq" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;8]</td><td><span><a class="reference external" href="https://musicbrainz.org/doc/General_FAQ">https://musicbrainz.org/doc/General_FAQ</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="beets-source" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;9]</td><td><span><a class="reference external" href="https://gist.github.com/sampsyo/1241307">https://gist.github.com/sampsyo/1241307</a></span>. [Stand: 12.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wiki-list-pop-music" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;10]</td><td><span><a class="reference external" href="http://en.wikipedia.org/wiki/List_of_popular_music_genres">http://en.wikipedia.org/wiki/List_of_popular_music_genres</a></span>. [Stand: 15.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wiki-list-az-music" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;11]</td><td><span><a class="reference external" href="http://en.wikipedia.org/wiki/List_of_music_styles">http://en.wikipedia.org/wiki/List_of_music_styles</a></span>. [Stand: 15.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="guess-language" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;12]</td><td><span><a class="reference external" href="https://bitbucket.org/spirit/guess_language">https://bitbucket.org/spirit/guess_language</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pyenchant" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;13]</td><td><span><a class="reference external" href="http://pythonhosted.org/pyenchant/">http://pythonhosted.org/pyenchant/</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="enchant" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;14]</td><td><span><a class="reference external" href="http://www.abisource.com/projects/enchant/">http://www.abisource.com/projects/enchant/</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pymining" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;15]</td><td><span><a class="reference external" href="https://github.com/bartdag/pymining">https://github.com/bartdag/pymining</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="aubio" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;16]</td><td><span><a class="reference external" href="https://github.com/piem/aubio">https://github.com/piem/aubio</a></span>. [Stand: 10.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="textblob" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;17]</td><td><span><a class="reference external" href="https://github.com/sloria/TextBlob">https://github.com/sloria/TextBlob</a></span>. [Stand: 10.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="igraph" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;18]</td><td><span><a class="reference external" href="http://igraph.sourceforge.net/">http://igraph.sourceforge.net/</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="cairo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;19]</td><td><span><a class="reference external" href="http://cairographics.org/">http://cairographics.org/</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="graphviz" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;20]</td><td><span><a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></span>. [Stand: 13.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="inkscape" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;21]</td><td><span><a class="reference external" href="http://www.inkscape.org">http://www.inkscape.org</a></span>. [Stand: 15.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="logos" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;22]</td><td><span><a class="reference external" href="http://libmunin.readthedocs.org/en/latest/media.html">http://libmunin.readthedocs.org/en/latest/media.html</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="html-variant" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Link&ndash;23]</td><td><span><a class="reference external" href="http://libmunin.readthedocs.org/en/latest/docs.html">http://libmunin.readthedocs.org/en/latest/docs.html</a></span>. [Stand: 14.4.2014].</td></tr>
</tbody>
</table>
</p>
</div>
<div class="section" id="lizenz">
<h2>Lizenz<a class="headerlink" href="#lizenz" title="Permalink to this headline">¶</a></h2>
<p>Diese Arbeit ist unter den Bedingungen der <em>Creative Commons Attribution-3.0</em>
lizensiert:</p>
<blockquote>
<div><a class="reference external" href="http://creativecommons.org/licenses/by/3.0/de/">http://creativecommons.org/licenses/by/3.0/de/</a></div></blockquote>
<a class="reference internal image-reference" href="../../_images/cclogo.svg"><div align="center" class="align-center"><img alt="Creative Commons License" src="../../_images/cclogo.svg" width="50%" /></div>
</a>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright by Christopher Pahl, 2013-2014..
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>