

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Projektarbeit</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../',
        VERSION:'0.1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="None" href="../index.html"/>

<!-- Include all CSS and JS files, let's you use your own theme. -->

<link rel="stylesheet" type="text/css" href="../_static/custom.css" />
<script type="text/javascript">
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}

    $(document).ready(function() {
    	var im, imsrc;
    	$('img').each(function() {
    		im = $(this);
    		imsrc = im.attr('src');
    		imalt = im.attr('alt');
    		if (endsWith(imsrc, 'svg')) {
    			im.wrap($('<a>').attr({'href': imsrc, 'title': imalt}).addClass('svglink'));
    		}
    	});

    	$('a.svglink').colorbox({
    		'width': '95%',
    		'height': '95%',
    		'photo': true});
    });
</script>


  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html#document-rst/index" class="icon icon-home"> Projektarbeit</a>
        <form class="wy-form" action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/acknowledgements">Danksagung</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/dedication">Widmung</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/I/index">1 Überleitung</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/II/index">2 Einstieg</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/II/index#warum-uberhaupt">2.1 Warum überhaupt?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/III/index">3 Algorithmen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/III/index#genre-normalisierung-und-vergleich">3.1 Genre-Normalisierung und Vergleich</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/IV/index">4 Graphenoperationen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#rebuild-aufbau-des-graphen">4.1 <tt class="docutils literal"><span class="pre">rebuild:</span></tt> Aufbau des Graphen</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#fixing-umbauen-von-einbahnstraszen">4.2 <tt class="docutils literal"><span class="pre">fixing:</span></tt> Umbauen von Einbahnstraßen</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#add-hinzufugen-von-songs-vor-dem-rebuild">4.3 <tt class="docutils literal"><span class="pre">add:</span></tt> Hinzufügen von Songs vor dem <tt class="docutils literal"><span class="pre">rebuild</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#remove-loschen-von-songs-zur-laufzeit">4.4 <tt class="docutils literal"><span class="pre">remove:</span></tt> Löschen von Songs zur Laufzeit</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#insert-hinzufugen-von-songs-zur-laufzeit">4.5 <tt class="docutils literal"><span class="pre">insert:</span></tt> Hinzufügen von Songs zur Laufzeit</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#modify-verandern-der-songattribute-zur-laufzeit">4.6 <tt class="docutils literal"><span class="pre">modify:</span></tt> Verändern der Songattribute zur Laufzeit</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/IV/index#ablauf-beim-hinzufugen-einer-distanz">4.7 Ablauf beim Hinzufügen einer Distanz</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/V/index">5 Implizites und explizites Lernen</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/VI/index">6 Evaluation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VI/index#allgemeine-hinweise-fur-entwickler">6.1 Allgemeine Hinweise für Entwickler</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VI/index#vergleich-verschiedener-playlisten">6.2 Vergleich verschiedener Playlisten</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/VII/index">7 Zusammenfassung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VII/index#verbesserung-der-algorithmik">7.1 Verbesserung der Algorithmik</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VII/index#erweiterung-der-algorithm">7.2 Erweiterung der Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VII/index#probleme-aktueller-algorithmen">7.3 Probleme aktueller Algorithmen</a></li>
<li class="toctree-l2"><a class="reference internal" href="rst/index.html#document-rst/VII/index#vergleich-von-zufalligen-playlisten-mit-libmunins-playlisten-mit-last-fm-playlists">7.4 Vergleich von zufälligen Playlisten mit libmunins Playlisten mit last.fm playlists</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix">Graphenbilder</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix#bilder-des-genregraphen">Bilder des Genregraphen</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/appendix#anhang-c">Anhang C</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/zzz_bibliography">Bibliographie</a></li>
<li class="toctree-l1"><a class="reference internal" href="rst/index.html#document-rst/zzz_bibliography#weblink-verzeichnis">Weblink Verzeichnis</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">Projektarbeit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="index.html#document-rst/index">Docs</a> &raquo;</li>
  <li><a href="">Projektarbeit</a></li>
  
</ul>
<hr/>

          
  <div class="section" id="libmunin-br-projektarbeit">
<span id="doc-title"></span><h1>libmunin: <br /> Projektarbeit<a class="headerlink" href="#libmunin-br-projektarbeit" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-rst/abstract"></span><div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
</div>
<p>This paper shows a way to build a music recommendation system based on
datamining algorithms and a neighbor graph. A extensible python library
is developed, using a variety of inputs differing from music metadata like
lyrics or the genre to the analysis of the associated audio data. In order to
demonstrate and verify the results, a Gtk+&ndash;based MPD client is developed that can
be used either as debugging tool or normal media player. Various techniques are
shown to compare all possible attributes of a song with each other in an
efficient way.</p>
<span id="document-rst/acknowledgements"></span><div class="section" id="danksagung">
<h2>Danksagung<a class="headerlink" href="#danksagung" title="Permalink to this headline">¶</a></h2>
</div>
<p>Danke an folgende Personen und Dinge: Katzen, Vögel aller Art, Teehersteller
aller Länder, Herrn Prof. Dr. Jörg Scheidt (für die Zelle), Herrn Prof. Dr.
Günter Köhler (für die Freiheit) und meiner Familie.</p>
<p>Ihr wisst schon warum.</p>
<span id="document-rst/dedication"></span><div class="section" id="widmung">
<h2>Widmung<a class="headerlink" href="#widmung" title="Permalink to this headline">¶</a></h2>
</div>
<p><em>Für meine Katzen.</em></p>
</div>
<div class="toctree-wrapper compound">
<span id="document-rst/abbrevs"></span><p><strong>Abkürzungsverzeichnis</strong></p>
<div class="figure align-center">
<center><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="headalign-center align-top">Abkürzung</th>
<th class="headalign-center align-top">Bedeutung</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td class="align-center align-top">API</td>
<td class="align-center align-top"><em>Application Programming Interface</em></td>
</tr>
<tr class="row-odd"><td class="align-center align-top">GUI</td>
<td class="align-center align-top"><em>Graphical User Interface</em></td>
</tr>
<tr class="row-even"><td class="align-center align-top">LoC</td>
<td class="align-center align-top"><em>Lines of Code</em></td>
</tr>
<tr class="row-odd"><td class="align-center align-top">ID</td>
<td class="align-center align-top"><em>Identifier</em></td>
</tr>
<tr class="row-even"><td class="align-center align-top">UID</td>
<td class="align-center align-top"><em>Unique Identifier</em></td>
</tr>
</tbody>
</table>
</center></div><span id="document-rst/I/index"></span><div class="section" id="uberleitung">
<h2>1 Überleitung<a class="headerlink" href="#uberleitung" title="Permalink to this headline">¶</a></h2>
<p>Implementierung vs. Evaluierung</p>
<p>MUUUSIK</p>
<p><a class="reference external" href="http://www2.research.att.com/~yifanhu/MusicMap/index.html">http://www2.research.att.com/&nbsp;yifanhu/MusicMap/index.html</a></p>
</div>
<span id="document-rst/II/index"></span><div class="section" id="einstieg">
<h2>2 Einstieg<a class="headerlink" href="#einstieg" title="Permalink to this headline">¶</a></h2>
<div class="section" id="warum-uberhaupt">
<h3>2.1 Warum überhaupt?<a class="headerlink" href="#warum-uberhaupt" title="Permalink to this headline">¶</a></h3>
<p>Eingehen auf Kaffeesatzlesen vs. Wissenschaft (Zeitmangel -&gt; Prototyp)</p>
<p>kein anspruch auf korrektheit, lediglich Hoffnung auf Nützlichkeit.</p>
<p>Fehlgeleitete Idee mit chromaprint erwähnen - tauglich um gleiche musikstücke
zu finden, aber nicht mehr.</p>
</div>
</div>
<span id="document-rst/III/index"></span><div class="section" id="algorithmen">
<h2>3 Algorithmen<a class="headerlink" href="#algorithmen" title="Permalink to this headline">¶</a></h2>
<div class="section" id="genre-normalisierung-und-vergleich">
<h3>3.1 Genre-Normalisierung und Vergleich<a class="headerlink" href="#genre-normalisierung-und-vergleich" title="Permalink to this headline">¶</a></h3>
<div class="section" id="problemstellung">
<h4>3.1.1 Problemstellung<a class="headerlink" href="#problemstellung" title="Permalink to this headline">¶</a></h4>
<p>Der Vergleich einzelner Genres ist eine schwierige Angelegenheit, da es,
zumindest im Bereich der Musik, keine standardisierte Einteilung von Genres
gibt. Ein Computer könnte höchstens erkennen wie ähnlich zwei
Genre Beschreibungen als Zeichenketten sind. Daher ist es nötig, dass die
einzelnen Genre-Eingaben anhand einer Sammlung von zusammengestellten Genre Daten
normalisiert werden.</p>
</div>
<div class="section" id="zusammenstellung-der-gernedatenbank">
<h4>3.1.2 Zusammenstellung der Gernedatenbank<a class="headerlink" href="#zusammenstellung-der-gernedatenbank" title="Permalink to this headline">¶</a></h4>
<p>Genres können, wie in einem Baum, in Genres (<em>rock</em>, <em>pop</em>), Unter-Genres
(<em>country</em> rock, <em>japanese</em> pop), Unter-Unter-Genres (<em>western</em> country rock) -
und so weiter - aufgeteilt werden. So lassen sich alle Genres und ihre
jeweiligen Unter-Genres als Baum darstellen. Als imaginären Wurzelknoten nimmt
man das allumfassende Genre <em>Music</em> an - einfach weil <em>Music</em> sich hinter fast
jedes Genre schreiben lässt ohne den Sinn zu verändern.</p>
<p>Dieser Baum kann dann genutzt werden um beliebige Genres anhand dieses Baums zu
normalisieren.</p>
<p>Die eigentliche Schwierigkeit besteht nun darin eine repräsentative Sammlung von
Genres in diesen Baum einzupflegen - bei der hohen Zahl der existierenden Genres
kann man diese nur schwerlich manuell einpflegen.</p>
<p>Existierende Datenbanken wie, das sonst sehr vollständige, <em>MusicBrainz</em> liefern
laut ihren FAQ keine Genre-Daten:</p>
<blockquote class="epigraph">
<div><p>WHY DOES MUSICBRAINZ NOT SUPPORT GENRE INFORMATION?</p>
<p><em>Because doing genres right is very hard.
We have thought about how to implement genres,
but we haven't completely settled on the right approach yet.</em></p>
<p class="attribution">&mdash;<a class="reference external" href="https://musicbrainz.org/doc/General_FAQ">https://musicbrainz.org/doc/General_FAQ</a></p>
</div></blockquote>
<p>Also musste man sich nach anderen Quellen umschauen. Das vom
<em>DiscogsGenre</em>-Provider verwendete <em>Discogs</em> bietet zwar relative detaillierte
Informationen, teilt aber die Genres hierarchisch in zwei Ebenen auf, dem
<em>Genre</em> (<em>rock</em>) und dem Subgenre (<em>blackened death metal</em>) - eine zu grobe
Einteilung.</p>
<p>Dafür fallen zwei andere Quellen ins Auge: <em>Wikipedia</em> - fast jede Band
ist dort vertreten und eben auch mit detaillierter Genre Information - sowie
<em>The Echonest</em> - einem Unternehmen welches verschiedene Dienste rund um
Musikmetadaten anbietet, darunter auch eine Liste von den ihnen bekannten
Genres.</p>
<p>Mit diesen zwei Quellen sollte man einen repräsentativen Durchschnitt aller
Genres bekommen. Zuerst muss man allerdings an die Daten herankommen. Bei
<em>The Echonest</em> ist dies, nachdem man sich einen <em>API Key</em> registriert hat
relativ einfach <a class="footnote-reference" href="#f1" id="id1"><sup>1</sup></a>:</p>
<blockquote>
<div><a class="reference external" href="http://developer.echonest.com/api/v4/artist/list_genres?api_key=XXXformat=json">http://developer.echonest.com/api/v4/artist/list_genres?api_key=XXXformat=json</a></div></blockquote>
<p>Die Liste enthält, zum Zeitpunkt des Schreibens, 898 konkrete Genres und wird
kontinuierlich von den Betreiber erweitert.</p>
<p>Die Suche bei Wikipedia gestaltet sich etwas schwieriger. Tatsächlich wurde
diese Quelle erst nachträglich nach einer Analyse des Quelltextes von <em>beets</em>
(<a class="reference external" href="https://gist.github.com/sampsyo/1241307">https://gist.github.com/sampsyo/1241307</a>) eingebaut. <em>beets</em> hat ebenfalls das
Problem das Genre zu normalisieren - also muss dort ein entsprechender
Mechanismus eingebaut sein. Dieser beruht, ähnlich wie hier, ebenfalls auf einem
Baum <a class="footnote-reference" href="#f2" id="id2"><sup>2</sup></a>. Um diese Quelle in <em>libmunin</em> zu nutzen wurde lediglich der Code
nach <em>Python3</em> portiert. Von der englischen Wikipedia werden folgende Seiten
<em>gescraped,</em> und die darin befindlichen Genres in eine Datei geschrieben:</p>
<ul class="simple">
<li>List of popular music genres</li>
<li>List of styles of music: A-F</li>
<li>List of styles of music: G-M</li>
<li>List of styles of music: N-R</li>
<li>List of styles of music: S-Z</li>
</ul>
<p>Von Wikipedia kommen 1527 Einträge. Diese werden mit den Einträgen von <em>,,The
Echonest''</em> verschmolzen. Nach einer Entfernung von Dubletten ist die finale
Genre-Liste 1876 Einträge lang.</p>
</div>
<div class="section" id="uberfuhrung-der-genreliste-in-einem-genrebaum">
<h4>3.1.3 Überführung der Genreliste in einem Genrebaum<a class="headerlink" href="#uberfuhrung-der-genreliste-in-einem-genrebaum" title="Permalink to this headline">¶</a></h4>
<div class="figure compound align-center" id="fig-tree">
<div style="width: 60%" class="subfigure align-center" id="fig-tree-input">
<a class="reference internal image-reference" href="../../_images/tree_input.svg"><img alt="Genreliste als Eingabe vor dem Prozessieren" src="../../_images/tree_input.svg" width="70%" /></a>
<p class="caption">Genreliste als Eingabe vor dem Prozessieren.</p>
</div>
<div style="width: 60%" class="subfigure align-center" id="fig-tree-init">
<a class="reference internal image-reference" href="../../_images/tree_init.svg"><img alt="Initialisierungsschritt" src="../../_images/tree_init.svg" width="100%" /></a>
<p class="caption">Initialisierungsschritt: Vergabe von IDs und Zuordnung zu Wurzelknoten.</p>
</div>
<div style="width: 60%" class="subfigure align-center" id="fig-tree-first">
<a class="reference internal image-reference" href="../../_images/tree_first.svg"><img alt="Der Genrebaum nach der ersten Iteration" src="../../_images/tree_first.svg" width="100%" /></a>
<p class="caption">Der Genrebaum nach der ersten Iteration, ,,swedish alternative'' noch nicht
aufgebrochen.</p>
</div>
<div style="width: 60%" class="subfigure align-center" id="fig-tree-final">
<a class="reference internal image-reference" href="../../_images/tree_final.svg"><img alt="Der fertige Genrebaum als Ausgabe." src="../../_images/tree_final.svg" width="100%" /></a>
<p class="caption">Der nach zwei Iterationen fertige Genrebaum.</p>
</div>
<p class="caption">Der Baum wird aus der Eingabe unter  erzeugt indem erst
alle Genres dem Wurzelknoten ,,music'' unterstellt werden
(). Danach wird der Baum rekursiv (hier in zwei
Schritten,  und )
immer weiter vertieft.</p>
</div><p id="fig-tree">Nachdem eine Liste von Genres nun vorhanden ist muss diese noch in einem Baum
wie in  gezeigt überführt werden.
Begleitend werden dazu die unter  gezeigte Genre-Liste als
Beispieleingabe. verwendet.</p>
<p>Der Baum sollte dabei folgende Kriterien erfüllen:</p>
<ul class="simple">
<li>Der Pfad von einem Blattknoten (<em>,,Swedish''</em>) zum Wurzelknoten (<em>,,music''</em>)
sollte dabei das ursprüngliche Genre, mit dem optionalen Suffix <em>music</em>
ergeben <em>(,,swedish-pop-music'')</em>.</li>
<li>Jeder Knoten erhält eine Integer-ID die für jeden Tiefenstufe von 0 wieder
anfängt. So hat der Knoten <em>music</em> immer die ID 0, bei der nächsten Ebene wird
die ID nach alphabetischer Sortierung vergeben, <em>pop</em> bekommt daher die 0,
<em>reggae</em> die 1, <em>rock</em> die 2.</li>
</ul>
<p>Das Umwandeln selbst geschieht folgendermaßen:</p>
<ul class="simple">
<li>Es wird manuell der Wurzelknoten <em>music</em> angelegt.</li>
<li>Alle Genres in der Genreliste werden diesem Knoten als Kinder hinzugefügt.
(siehe Abbildung )</li>
<li>Dann wird rekursiv folgende Prozedur erledigt:<ol class="arabic">
<li>Gehe über alle Kinder des Wurzelknoten und breche dabei das <em>letzte Element</em>
Wort des <em>Genres</em> ab (<em>western country rock</em> wird zu <em>western country</em> und
<em>rock</em>).</li>
<li>Der letzte Teil wird als Schlüssel in einer Hashmap gespeichert, mit dem
Rest als dazugehöriger Wert. Dies entledigt sich, aufgrund der Natur von
Hashmaps, eventueller Dupletten.</li>
<li>Die Liste der Kinder des Wurzelknotens wird zu einer leeren Liste
zurückgesetzt.</li>
<li>Die Schlüssel der Hashmap werden als neue Kinder gesetzt, die dazugehörigen
Werte als deren Kinder.</li>
<li>Iteriere über die neuen Kinder, jedes Kind wird als neuer Wurzelknoten
angenommen und es wird von 1) an begonnen. Der Rekursionsstopp ist erreicht
wenn keine Aufteilung des Genres in letztes Element und Rest mehr möglich
ist.</li>
</ol>
</li>
<li>In unserem Beispiel ist der Baum bereits nach zwei Iterationen fertig
(). In  ist der Baum nach der ersten
Iteration zu sehen.</li>
<li>Nach dem manuellen Aufbau werden noch einige halbautomatische Aufräumarbeiten
erledigt:<ol class="arabic">
<li>die fehlenden ,,Musik''-Genres <em>,,vocal''</em> und <em>,,speech''</em> werden
manuell eingefügt.</li>
<li>Bei dem momentanen Vorgehen landen unter Umständen weitere ,,*music*''
auf der ersten Ebene. Diese werden bereinigt.</li>
<li>Alle Genres die auf <em>,,core''</em> enden werden aufgebrochen und dem Knoten
<em>,,core''</em> auf erster Ebene hinzugefügt.</li>
</ol>
</li>
</ul>
<p>Der resultierende Baum ist im Anhang <em class="xref std std-ref">genre-graph-vis</em> in verschiedenen
Detailstufen visualisiert.  Er besitzt auf der ersten Ebene 1044 Unter-Genre. Die
tiefste Verschachtelung erreicht das Genre <em>,,New Wave of new Wave''</em> mit einer
Tiefe von 5.</p>
</div>
<div class="section" id="matching-von-genres">
<h4>3.1.4 Matching von Genres<a class="headerlink" href="#matching-von-genres" title="Permalink to this headline">¶</a></h4>
<p>Die Normalisierung des Genres ist nun mit dem aufgebauten Baum recht einfach.
Zuerst muss das Eingabegenre in Subgenres aufgeteilt werden - oft sind mehrere
Genres in einem einzelnen String zusammengefasst, die durch bestimmte Zeichen
getrennt sind. Ein Beispiel:</p>
<blockquote>
<div><em>,,Rock, Reggae / Alternative Rock, Ska, Punk''</em></div></blockquote>
<p>Jedes dieser Subgenres wird dann mittels eines regulären Ausdruckes in einzelne
Wörter aufgeteilt. Die Wörter werden noch in die kleingeschriebene Form
gebracht. In der Python-Listen Syntax sähe das obige Beispiel dann so aus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[[</span><span class="s">&#39;rock&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;reggae&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;alternative&#39;</span><span class="p">,</span> <span class="s">&#39;rock&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;ska&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;punk&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Die einzelnen Wortlisten können jetzt in <em>Pfade</em> umgewandelt werden.
Dazu wird folgendermaßen vorgegangen:</p>
<ul class="simple">
<li>Es wird eine leere Liste von Pfaden angelegt.</li>
<li>Es wird eine Liste mit Wahrheitswerten angelegt, die genauso lang ist wie die
Wortliste. Die Wahrheitswerte werden auf <em>False</em> initialisiert.
Diese <em>Maske</em> wird genutzt um bereits gefundene Wörter ,,ab zu haken''.</li>
<li>Es wird eine leere <em>,,results''</em> Liste angelegt.</li>
<li>Dann wird eine rekursive Suche nach passenden <em>Pfaden</em> mit dem Wurzelknoten
<em>music</em> gestartet:<ol class="arabic">
<li>Schaue ob der momentane Wurzelknoten Kinder enthält die auch in der
Wortliste vorkommen. Wenn das entsprechende Wort noch nicht in der <em>Maske</em>
abgehakt wurde, wird es in eine temporäre Liste <em>,,children''</em> aufgenommen.</li>
<li>Wenn <em>,,children''</em> leer ist und die <em>,,results''</em> Liste nicht leer, so
wird die letzere zur Pfadliste hinzugefügt.</li>
<li>Es wird über jedes Kind in der <em>,,children''</em> Liste iteriert. Bei jeder
Iteration wird:<ol class="upperalpha">
<li>Eine Kopie der <em>,,results''</em> Liste wird erstellt, bei der die ID des
Kindes am Ende hinzugefügt wurde.</li>
<li>Eine Kopie der <em>Maske</em> wird erstellt, in der das vom Kind repräsentierte
Wort <em>,,abgehakt''</em> (der entsprechende Index wird auf <em>True</em> gesetzt)
wird.</li>
<li>Das Kind wird als neuer Wurzelknoten angenommen und es wird wie bei 1)
weitergemacht.  Der Rekursionsstopp ist dann erreicht wenn die
<em>,,children''</em> Liste leer ist.</li>
</ol>
</li>
<li>Nach dem Rekursionsstopp stehen alle validen Pfade in der Pfadliste.</li>
</ol>
</li>
</ul>
<p>Das Bedarf vermutlich eines Beispiels. Nehmen wir das Subgenre <em>,,alternative
rock''</em> zur Demonstration her.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/tree_match_example.svg"><img alt="Beispielablauf des Matching Algorithmusses" src="../../_images/tree_match_example.svg" width="100%" /></a>
<p class="caption">Beispiel-Ablauf des ,,Matching'' an der Eingabe ,,alternative rock''. In den
Knoten ist die jeweils die momentante Maske eingetragen, an den Kanten das
aktuelle Ergebniss.</p>
</div>
<p>Die passenden Pfade sind in diesem Fall also <em>alternative</em> und <em>alternative rock</em>.
Es ist zu bemerken dass <em>rock</em> zwar ebenfalls ein valider Pfad ist, aber
als eine Untermenge von <em>alternative rock</em> nicht in der Ergebnismenge ist.</p>
</div>
<div class="section" id="vergleichen-der-unterschiedlichen-genre-pfade-mengen">
<span id="single-dist"></span><h4>3.1.5 Vergleichen der unterschiedlichen Genre-Pfade-Mengen<a class="headerlink" href="#vergleichen-der-unterschiedlichen-genre-pfade-mengen" title="Permalink to this headline">¶</a></h4>
<p>Um zwei einzelne Pfade miteinander zu Vergleich wird wie im Folgenden
vorgegangen:</p>
<ul class="simple">
<li>Zähle die Anzahl an Punkten in denen sich der Pfad überdeckt.</li>
<li>Teile die Anzahl durch die Länge des längeren beider Pfade.</li>
<li>Die daraus gewonnene Ähnlichkeit wird von <span class="math">\(1.0\)</span> abgezogen um die Distanz
zu erhalten.</li>
</ul>
<p>In <em>libmunin</em> sind zwei Distanzfunktionen erhalten welche diese Methode nutzt um
zwei Mengen mit Genrepfaden zu vergleichen.</p>
<p><tt class="docutils literal"><span class="pre">GenreTree</span></tt>: Vergleicht jeden Genrepfad in den Mengen <em>A</em> und <em>B</em> mittels oben
genannter Methode miteinander. Die minimalste Distanz wird zurückgegeben.  Als
Optimierung wird frühzeitig abgebrochen wenn eine Distanz von <span class="math">\(0.0\)</span>
erreicht wird.</p>
<p>Diese Distanzfunktion eignet sich für eher kurze Genre-Beschreibungen wie sie in
vielen Musiksammlungen vorkommen. Meist ist dort ein Lied als <em>rock</em> oder
<em>metal</em> eingetragen, ohne Unterscheidung von Subgenres. Deshalb geht diese
Distanzfunktion davon aus wenige Übereinstimmungen zu finden - sollten welche
vorkommen werden diese gut bewertet.</p>
<p>Setzt man voraus, dass <em>d</em> die unter <a class="reference internal" href="rst/index.html#single-dist">3.1.5</a> erwähnte
<em class="xref std std-term">Distanzunktion</em> ist,  so berechnet sich die finale Distanz durch:</p>
<div class="math">
\[D(A, B) = \argmin\!\bigg(\displaystyle\sum\limits_{a \in A}{\displaystyle\sum\limits_{b \in B} d(a, b)}\bigg)\]</div>
<p><tt class="docutils literal"><span class="pre">GenreTreeAvg</span></tt>: Seien <em>A</em> und <em>B</em> zwei Mengen mit Genrepfaden. <em>A</em> ist dabei
die größere Menge und <em>B</em> die kleinere, falls die Mengen eine unterschiedliche
Mächtigkeit besitzen.</p>
<div class="math">
\[D(A, B) = \frac{\displaystyle\sum\limits_{a \in A} \argmin\!{\Bigg(\displaystyle\sum\limits_{b \in B} d(a, b)\Bigg)}}{\vert A\vert}\]</div>
<p>Diese Distanzfunktion eignet sich für <em>,,reichhaltig''</em> befüllte
Genrebeschreibungen bei denen auch ein oder mehrere Unter-Genres vorhanden sind.
Ein Beispiel dafür wäre: <tt class="docutils literal"><span class="pre">country</span> <span class="pre">rock</span> <span class="pre">/</span> <span class="pre">folk</span> <span class="pre">/</span> <span class="pre">rockabilly</span></tt>. Die
Distanzfunktion geht also davon aus zumindest teilweise Überdeckungen in den
Daten vorzufinden.</p>
<p>Je nach Daten die es zu verarbeiten gilt, kann der Nutzer der Bibliothek eine
passende <em class="xref std std-term">Distanzunktion</em> auswählen.</p>
</div>
<div class="section" id="probleme">
<h4>3.1.6 Probleme<a class="headerlink" href="#probleme" title="Permalink to this headline">¶</a></h4>
<p>Insgesamt funktioniert dieser Ansatz relativ gut, die meisten Genre werden
zufriedenstellend in Pfade normalisiert die performant verglichen werden können.</p>
<p>Folgendes Problem wird allerdings noch nicht zufriedenstellend gelöst:
Es wird davon ausgegangen, dass Genres die ähnlich sind auch ähnlich heißen -
eine Annahme die zwar oft, aber nicht immer wahr ist. So sind die Genres
<em>Alternative Rock</em> und <em>Grunge</em> sehr ähnlich - der obige Ansatz würde hier
allerdings eine Distanz von <span class="math">\(0.0\)</span> liefern. Auch Genres wie <em>,,rock'n'roll</em>
würde ähnlich schlechte Resultate liefern.</p>
<p>Eine mögliche Lösung wäre eine Liste von ,,Synonymen'' Genres die
Querverbindungen im Baum erlauben würden.</p>
<p>Allerdings wäre eine solche Liste von Synonymen relative schwer automatisch zu
erstellen.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Der <em>API Key</em> wurde in der URL gekürzt da man angehalten ist diesen
nicht zu veröffentlichen.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Anmerkung: Die Idee entstand allerdings ohne Kenntnis von <em>beets</em>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="keword-extraction">
<h4>3.1.7 Keword Extraction<a class="headerlink" href="#keword-extraction" title="Permalink to this headline">¶</a></h4>
<p>KeywordExtraction - KeywordSelection - KeywordDistance</p>
</div>
<div class="section" id="rule-generation">
<h4>3.1.8 Rule Generation<a class="headerlink" href="#rule-generation" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="graph-generation">
<h4>3.1.9 Graph Generation<a class="headerlink" href="#graph-generation" title="Permalink to this headline">¶</a></h4>
<p>add, rebuild, fix_graph</p>
</div>
<div class="section" id="distance-add">
<h4>3.1.10 distance_add<a class="headerlink" href="#distance-add" title="Permalink to this headline">¶</a></h4>
<p>&quot;max_neighbors Dilemma&quot;</p>
</div>
<div class="section" id="graphenoperationen">
<h4>3.1.11 Graphenoperationen<a class="headerlink" href="#graphenoperationen" title="Permalink to this headline">¶</a></h4>
<p>insert, remove, modify</p>
</div>
<div class="section" id="graphentraversierung">
<h4>3.1.12 Graphentraversierung<a class="headerlink" href="#graphentraversierung" title="Permalink to this headline">¶</a></h4>
<p>Infinite Iteratos - konzept aus funktionalen Programmiersprachen wie Haskell</p>
</div>
<div class="section" id="sieving-algorithm">
<h4>3.1.13 Sieving Algorithm<a class="headerlink" href="#sieving-algorithm" title="Permalink to this headline">¶</a></h4>
<p>Erklärung &amp; Configuration.</p>
</div>
<div class="section" id="various-providers">
<h4>3.1.14 Various Providers<a class="headerlink" href="#various-providers" title="Permalink to this headline">¶</a></h4>
<p>Erwähnenswerte Algorithmik hinter den anderen Providern.</p>
<p>levenshtein, bpm, moodbar, wordlist distance, normalize provider, stemming</p>
</div>
</div>
</div>
<span id="document-rst/IV/index"></span><div class="section" id="graphenoperationen">
<h2>4 Graphenoperationen<a class="headerlink" href="#graphenoperationen" title="Permalink to this headline">¶</a></h2>
<p>Eine grobe Übersicht über die einzelnen Graphenoperationen und ihrer
Zuständigkeiteb wurde bereits in der Projektarbeit gegeben. Im Folgenden
wird detailliert auf ihre Funktionsweise eingegangen.</p>
<div class="section" id="rebuild-aufbau-des-graphen">
<h3>4.1 rebuild: Aufbau des Graphen<a class="headerlink" href="#rebuild-aufbau-des-graphen" title="Permalink to this headline">¶</a></h3>
<p>Bevor irgendeine andere Operation ausgeführt werden kann muss mittels der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation der Graph aufgebaut
werden. Wie bereits erwähnt in der Projektarbeit erwähnt, kann der Graph
aufgrund von einer Komplexität von <span class="math">\(O(n2)\)</span> nicht einfach durch das
Vergleichen aller Songs untereinander erfolgende. Daher muss eine Lösung mit
subquadratischen Aufwand gefunden werden. Vorzugsweise eine, bei der
Rechenaufwand gegen die Qualität der Approximation abgewägt werden kann.
So kann der Nutzer entscheiden wie lange er <em>libmunin</em> rechnen lassen will.</p>
<p>Der Ausgangszustand der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operationen ist eine Liste von Songs die
vom Nutzer bereitgestellt wird. Jeder Song darin soll nun so im Graphen
platziert werden, dass er im Bestfall die ähnlichsten Songs als Nachbarn
hat.</p>
<p>Jeder Song speichert seine Nachbarn mit der dazugehörigen Distanz.
Soll ein neuer Nachbar hinzugefügt werden, so wird geprüft ob die Distanz zu
diesem neuen Song besser ist als die zum schlechtesten vorhandenen Nachbar.
Ist dies der Fall, so wird die Entfernung zu diesem schlechtesten Nachbarn <em>in
eine Richtung</em> (die Gründe hierfür werden später betrachtet TODO) gekappt. Als
Ersatz wird zu dem neuen Song eine bidirektionale Verbindung aufgebaut. Da die
Verbindung zum schlechtesten Song nur unidirektional abgebaut wird, ist die
Anzahl der Nachbarn eines Songs nicht auf einen Maximum begrenzt, da das
Hinzufügen neuer Songs <em>,,Einbahnstraßen&quot;</em> hinterlässt.</p>
<p>Vielmehr handelt es sich dabei um einen Richtwert, um den sich die tatsächliche
Anzahl der Songs einpendeln wird. Momentan ist dieser Richtwert standardmäßig
auf <span class="math">\(15\)</span> gesetzt &mdash; der durchschnittlichen Länge eines heutigen Albums
plus eins.</p>
<p>Wenn im folgenden vom <em>,,Berechnen der Distanz&quot;</em> gesprochen wird, so ist damit
auch das Hinzufügen der Distanz zu den jeweiligen Song gemeint.</p>
<div class="figure compound align-center" id="fig-windows">
<div style="width: 50%" class="subfigure align-center" id="fig-window-sliding">
<a class="reference internal image-reference" href="../../_images/sliding_window.svg"><img alt="Schematische Darstellung des Sliding Window." src="../../_images/sliding_window.svg" width="100%" /></a>
<p class="caption"><tt class="docutils literal"><span class="pre">sliding_window</span></tt></p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-centering">
<a class="reference internal image-reference" href="../../_images/centering_window.svg"><img alt="Schematische Darstellung des Sliding Window." src="../../_images/centering_window.svg" width="100%" /></a>
<p class="caption"><tt class="docutils literal"><span class="pre">sliding_window</span></tt></p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-anti-centering">
<a class="reference internal image-reference" href="../../_images/anti_centering_window.svg"><img alt="Schematische Darstellung des Sliding Window." src="../../_images/anti_centering_window.svg" width="100%" /></a>
<p class="caption"><tt class="docutils literal"><span class="pre">sliding_window</span></tt></p>
</div>
<p class="caption">Schematische Darstellungen der einzelnen Basisiterationen.</p>
</div><p id="fig-windows">Im Folgenden werden die drei Schritte der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation genauer
beleuchtet:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Für jeden Song wird nach willkürlich festgelegten
Prinzipien eine kleine Menge von möglicherweise ähnlicher Songs ausgewählt.
Diese Menge von Songs wird untereinander mit quadratischen Aufwand verglichen.
Diese Vorgehensweise wird mehrmals mit verschiedener Methoden wiederholt. Das
Ziel jeder dieser Iterationen ist es für einen Song zumindestens eine kleine
Anzahl von ähnlichen Songs zu finden. Basierend auf diesen wird in den
nächsten Schritten versucht die Anzahl ähnlicher Songs zu vergrößern.</p>
<p>Momentan sind drei verschiedene Iterationsstrategien implementiert. Jede
basiert auf gewissen heuristischen Annahmen die über die Eingabemenge gemacht
wird:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">sliding_window:</span></tt> Schiebt ein <em>,,Fenster&quot;</em> über die Liste der Songs.
Alle Songs innerhalb des Fensters werden untereinander verglichen.  Die
Fenstergröße ist dabei konfigurierbar und ist standardmäßig auf 60
eingestellt, da sich diese Größe nach einigen Tests als guter Kompromiss
zwischen Qualität und Geschwindigkeit herausgestellt hat.  Bei jeder
Iteration wird das Fenster um ein Drittel der Fenstergröße weitergeschoben.
Dadurch entsteht eine <em>,,Kette&quot;</em> von zusammenhängenden Songs.</p>
<p>Die heuristische Annahme ist dabei, dass der Nutzer der Bibliothek seine
Datenbank meist nach Alben sortiert eingibt. Durch diese Sortierung finden
sich innerhalb eines Fensters oft Lieder des selben Albums &mdash; diese  sind
oft sehr ähnlich.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">centering_window:</span></tt> Basiert ebenfalls auf einem Fenster. Im Gegensatz
zum obigen <tt class="docutils literal"><span class="pre">sliding_window</span></tt> besteht das Fenster allerdings aus zwei Hälften,
wobei die eine vom Anfang an startet und die andere Hälfte von der Mitte
aus bis zum Ende geschoben wird. Die Songs in beiden Hälften werden analog
zu oben untereinander verglichen. Auch hier überlappen sich die einzelnen
Hälften zu je zwei Drittel.</p>
<p>Die heuristische Annahme ist hier, dass in der bereits vorhandenen
<em>,,Kette&quot;</em> Querverbindungen hergestellt werden. Dies ist den nächsten
Schritten vorteilhaft um Iterationen einzusparen.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">anti_centering_window:</span></tt> Sehr ähnlich zum <tt class="docutils literal"><span class="pre">centering_window</span></tt>, statt
die zwei Hälfte aber von der Mitte aus bis zum Ende weiter zu schieben
wird diese vom Ende zur Mitte geschoben. So werden die beiden Hälften
solange weiter geschoben, bis sie sich in er Mitte treffen.</p>
<p>Auch hier sollen weitere Querverbindungen hergestellt werden.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Um den momentan sehr grob vernetzten Graphen benutzbar zu
machen müssen einige Iterationen zur <em>,,Verfeinerung&quot;</em> durchgeführt werden.</p>
<p>Dabei wird über jeden Song im Graphen iteriert und dessen <em>indirekte Nachbarn</em>
(also die Nachbarn der direkten Nachbarsongs) werden mit dem aktuellen Song
verglichen. Kommen dabei Distanzen zustande, die niedriger sind als die der
aktuellen Nachbarn, wird der indirekte Nachbar zum direkten Nachbarn. Auf
diese Weise rücken ähnliche Songs immer weiter aufeinander zu.
Diese Vorgehensweise wird solange wiederholt bis nur noch eine geringe Anzahl
von Songs <em>,,bewegt&quot;</em> oder bis eine maximale Anzahl von Iterationen erreicht
ist. Die Begrenzung der Iterationen ist nötig, da es Fälle geben kann in denen
einzelne Songs immer wieder zwischen zwei gleich guten Zuständen hin- und
herspringen können.</p>
<p>Als zusätzliche Optimierung werden nicht alle indirekten Nachbarn betrachtet,
sondern nur diese, zu denen der Weg eine gewisse <em>Mindestdistanz</em> nicht
unterschreitet. Diese Mindestdistanz wird beim Start dabei auf <span class="math">\(2.0\)</span>
gesetzt und während der folgenden Iterationen immer weiter abgesenkt.</p>
<p>Die Gesetzmäßigkeit nach der die Mindesdistanz immer weiter abgesenkt wird ist
dabei wie folgt beschrieben:</p>
<div class="math">
\[\frac{4 \times mean - 2 \times sd)}{2}\]</div>
</li>
<li><p class="first"><strong>Aufräumearbeiten:</strong> Nach dem Verfeinerungsschritt wird der Graph von
Einbahnstraßen durch einen <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt bereinigt und auf Konsistenz
geprüft.</p>
</li>
</ul>
<p>Wie bereits erwähnt gibt es eine <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt>&ndash;Operation, welche für
deutlich kleinere Mengen von Songs praktikabel einsetzbar ist. Die Algorithmik
ist hierbei bedeutend einfacher: Es wird einfach jeder Song mit jedem anderen
verglichen. Als Nachbarn erhält dabei jeder Song die Nachbarn, die global
betrachtet die kleinste Distanz zu diesem besitzen. Es handelt sich als um keine
Approximation wie beim herkömmlichen <tt class="docutils literal"><span class="pre">rebuild</span></tt>.</p>
<p>Auf die Betrachtung der Komplexität der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation wird an dieser
Stelle verzichtet. Keine der einzelnen Schritte erreicht dabei quadratische
Komplexität.  Die einzige Ausnahme ist dabei das Vergleichen der Songs
untereinander innerhalb eines Fensters, allerdings ist dabei  die Fenstergröße
stets auf ein verträgliches Limit begrenzt.</p>
<p>Unter Abb.  findet sich eine Gegenüberstellung von den
Aufrufen der Distanzfunktion, die bei <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt> und beim normalen
<tt class="docutils literal"><span class="pre">rebuild</span></tt> (mit und ohne <em>Verfeinerungsschritt</em>) nötig sind.</p>
<div class="figure align-center" id="fig-speed-cmp">
<a class="reference internal image-reference" href="../../_images/graph_speed.svg"><img alt="Vergleich der Distanzberechnungen für rebuild_stupid und rebuild." src="../../_images/graph_speed.svg" width="100%" /></a>
<p class="caption">Gegenüberstellung von verschiedenen Arten der rebuild&ndash;Operation. Auf der
Y&ndash;Achse ist logarithmisch die Anzahl der Distanzberechnungen aufgetragen,
auf der X&ndash;Achse die lineare Anazhl der Eingabesongs. Die blaue Kurve
repräsentiert dabei die Vergleiche die für rebuild_stupid notwendig sind.
Wie man sieht, übersteigen diese bis auf dem Gleichheitsbereich am Anfang die
anderen zwei Kurven deutlich.</p>
</div>
<p>Die einzelnen Schritte des Graphenaufbaus lassen sich in Abb.
, sowie bei den darauf folgenden Abbildungen,
nachvollziehen.</p>
</div>
<div class="section" id="fixing-umbauen-von-einbahnstraszen">
<h3>4.2 fixing: Umbauen von Einbahnstraßen<a class="headerlink" href="#fixing-umbauen-von-einbahnstraszen" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation dient dem Entfernen von Einbahnstraßen innerhalb des Graphen.
Einbahnstraßen können wie bereits erwähnt beim Hinzufügen neuer Distanzen
entstehen.</p>
<p>Beim Entfernen wird folgendermaßen vorgegangen: Im ersten Schritt werden alle
unidirektionalen Kanten gefunden und abgespeichert. Für jede dieser Kanten wird
überprüft ob die Songs an beiden Enden den Richtwert für die Anzahl der Nachbarn
überschreitet. Sollte das nicht der Fall, so wird die Kante in eine
bidirektionale Kante umgebaut. Andernfalls wird die Kante gelöscht.</p>
<p>Dieses Vorgehen wurde gewählt weil es nach einigen Versuchen schwierig erschien,
den Graphen ohne Einbahnstraßen aufzubauen, ohne dass dieser zur Inselbildung
neigt. Durch den nachgelagerten <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt werden Songs die nur wenige
Nachbarn besitzen durch die vorher als zu schlecht bewerteten Kanten verbunden.</p>
<p>Als zusätzliche Konsistenzprüfung wird nach dem Bereinigen geprüft ob alle
Verbindungen im Graphen bidirektional sind. Sollten unidirektionale Kanten
gefunden werden, so wird eine Warnung ausgegeben.</p>
</div>
<div class="section" id="add-hinzufugen-von-songs-vor-dem-rebuild">
<h3>4.3 add: Hinzufügen von Songs vor dem <tt class="docutils literal"><span class="pre">rebuild</span></tt><a class="headerlink" href="#add-hinzufugen-von-songs-vor-dem-rebuild" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation benötigt als Argument eine Hashtabelle mit einer Abbildung von
Attributen auf Werte. Diese Werte werden dann wie in der Projekarbeit besprochen
durch verschiedene Provider normalisiert. Mit diesen normalisierten
Informationen wird dann eine neue Song&ndash;Instanz erzeugt, welcher beim Erzeugen
ein eindeutiger Identifier zugewiesen wird. Dieser Identifier dient dann als
Index in er internen Songliste.</p>
<p>Statt wie <tt class="docutils literal"><span class="pre">insert</span></tt> bereits Verbindungen zu anderen Songs herzustellen, fügt
diese Operation lediglich einen Song der internen Songliste hinzu.</p>
</div>
<div class="section" id="remove-loschen-von-songs-zur-laufzeit">
<h3>4.4 remove: Löschen von Songs zur Laufzeit<a class="headerlink" href="#remove-loschen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Um nach einer <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation einen Song auf dem Graphen zu löschen
müssen alle Verbindungen zu diesem entfernt werden.  Um dabei eine Bildung von
Inseln (durch das Entfernen von Verbindungen) zu vermeiden, werden alle
ursprünglichen Nachbarn des zu entfernenden Songs untereinander verbunden. Dabei
wird folgendermaßen vorgegangen: Zuerst wird temporär für jeden Nachbarn den
Richtwert für die Anzahl der Nachbarn um eins erhöht. Im Anschluss wird die
Menge aller Nachbarn untereinander mit quadratischem Aufwand verglichen. Dadurch
bekommt jeder Nachbar im besten Fall eine neue Verbindung.  Abschließend werden
alle Verbindungen zum zu löschenden Song entfernt und der Richtwert wird wieder
um eins dekrementiert.</p>
<p>Da <em>libmunin</em> alle Songs in einer linearen List hält muss auch dort der Song
gelöscht werden. Da der Index des Songs in der Liste gleich der <em>UID</em> des Songs
ist, wird an der Stelle <em>UID</em> ein leerer Wert geschrieben. Damit dieser
möglichst bald wieder besetzt wird, wird die gelöschte <em>UID</em> in einer
<em>Revocation</em>&ndash;List gespeichert. Beim nächsten <tt class="docutils literal"><span class="pre">add</span></tt> oder <tt class="docutils literal"><span class="pre">insert</span></tt> wird diese
<em>UID</em> dann wiederverwendet.</p>
</div>
<div class="section" id="insert-hinzufugen-von-songs-zur-laufzeit">
<h3>4.5 insert: Hinzufügen von Songs zur Laufzeit<a class="headerlink" href="#insert-hinzufugen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation ist äquivalent <tt class="docutils literal"><span class="pre">add</span></tt>. Als Erweiterung fügt <tt class="docutils literal"><span class="pre">insert</span></tt>
allerdings den durch <tt class="docutils literal"><span class="pre">add</span></tt> erzeugten Song auch in den Graphen ein und
verbindet ihn dort. Dazu muss zuerst ein <em>Punkt</em> gefunden werden an dem der Song
passend zu seinen Attributen <em>eingepasst</em> werden kann.</p>
<p>Diese <em>Einpassung</em> geschieht dabei folgendermaßen:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Es wird mit einer gewissen <em>Schrittweite</em> über die
Songliste iteriert. Dabei werden die Distanzen vom momentan aktuellen Song zum
einzufügenden Song berechnet. Dadurch wird der Song bereits mit einigen
anderen Songs verknüpft.  Die Größe der Schrittweite ist dabei abhängig von
der Länge der Songliste.  Je länger die Liste ist, desto größer ist die
Schrittweite.  Exakt ist sie dabei folgendermaßen definiert:</p>
<div class="math">
\[Schrittweite = \lceil\log_{10}songlist\_length\rceil\]</div>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Songs, zu denen im vorigen Schritt eine geringe Distanz
gefunden wurde, werden nun detaillierter betrachtet. Dazu wird die Distanz zu
den Nachbarn dieser <em>guten</em> Songs berechnet, unter der bekannten Annahme, dass
die indirekten Nachbar des einzufügenden Songs auch als potenzielle direkte
Nachbarn taugen.</p>
</li>
</ul>
<p>Als zusätzliche Beobachtung lässt sich feststellen, dass Songs die per
<tt class="docutils literal"><span class="pre">insert</span></tt> eingefügt werden deutlich <em>weitläufiger</em> verbunden sind als regulär
per <tt class="docutils literal"><span class="pre">add</span></tt> hinzugefügte. Diese Eigenschaft macht sich die in der Projektarbeit
gezeigte Demonanwedung zu Nutze: Ändert man das <em>Rating</em> eines Songs, so wird
der Song mitels <tt class="docutils literal"><span class="pre">remove</span></tt> gelöscht und mittels  <tt class="docutils literal"><span class="pre">insert</span></tt> anderswo wieder
eingefügt. Meist verbindet sich dabei der Song dann mit anderen ähnlich
bewerteten Songs. Diese bilden ein <em>zusätzliches Netz</em> über den Graphen, welches
weitläufrigere Sprünge ermöglicht.
Dadurch hat der Nutzer eine intuitive Möglichkeit den Graphen
seinen Vorstellungen nach umzubauen.</p>
</div>
<div class="section" id="modify-verandern-der-songattribute-zur-laufzeit">
<h3>4.6 modify: Verändern der Songattribute zur Laufzeit<a class="headerlink" href="#modify-verandern-der-songattribute-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation dient als Komfortfunktion. Sie ermöglicht das Verändern der
Attribute, beziehungsweise deren zugeordneten Werte, eines einzelnen Songs.
Würde man die Werte eines Songs manuell verändern, so müsste man alle Distanzen
zu diesem Song neu berechnen. Da dies wiederum Veränderungen im ganzen Graphen
hervorrufen könnte, wurden die Song&ndash;Instanzen unveränderbar <em>(,,Immutable&quot;)</em>
gemacht.</p>
<p>Die <tt class="docutils literal"><span class="pre">modify</span></tt>&ndash;Operation umgeht dieses Problem indem es den Song erst durch ein
<tt class="docutils literal"><span class="pre">remove</span></tt> entfernt und eine Kopie des ursprünglichen Songs macht, in der die
neuen Werte gesetzt werden. Dieser neue, noch unverbundene Song wird dann
mittels einer <tt class="docutils literal"><span class="pre">insert</span></tt>&ndash;Operation in den Graphen eingepasst.</p>
<p>Aufgrund dieser Abfolge unterschiedlicher Operation ist <tt class="docutils literal"><span class="pre">modify</span></tt> relativ
aufwendig. Es wird empfohlen diese Operation nur für einzelne Song jeweils
einzusetzen. Sollte ein bestimmtes Attribut in allen Songs geändert werden, so
ist eine <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation zu empfehlen.</p>
</div>
<div class="section" id="ablauf-beim-hinzufugen-einer-distanz">
<h3>4.7 Ablauf beim Hinzufügen einer Distanz<a class="headerlink" href="#ablauf-beim-hinzufugen-einer-distanz" title="Permalink to this headline">¶</a></h3>
<p>Wie in TODO erwähnt, wird beim Hinzufügen einer Distanz die Schlechteste dem
Song bekannte Distanz abgefragt. Ist diese höher als die Neue wird der
Verbindung zum schlechtesten Song <em>gekappt</em> falls der Song <em>voll</em> ist.</p>
<p>Dieses Vorgehen bringt aber bereits einige algorithmische Probleme mit
sich: Das Finden der schlechtesten Distanz erfordert jeweils linearen Aufwand.
Zwar kann die schlechteste Distanz und der dazugehörige Song zwischengespeichert
werden, doch nach einigen Tests stellte sich heraus, dass in den meisten Fällen
ein neuer, schlechtester Song gesucht werden muss. Das ist damit zu erklären,
dass gegen Ende der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation tendenziell immer niedrigere Distanzen
gefunden werden &mdash; womit immer wieder der schlechteste Song herausgelöscht
werden muss.</p>
<p>Hier ein performanten Ansatz zu finden war mit 2 Wochen relativ zeitaufwendig.</p>
<p>Als Python&ndash;Pseudocode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">distance_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">distance</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_distance</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">sdd</span><span class="p">,</span> <span class="n">odd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dist_dict</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">sdd</span><span class="p">:</span>
        <span class="c"># Sollte nicht passieren:</span>
        <span class="k">if</span> <span class="n">sdd</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">sdd</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">odd</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="c"># Check if we still have room left</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sdd</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_neighbors</span><span class="p">:</span>
        <span class="c"># Find the worst song in the dictionary</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">inversion</span><span class="p">,</span> <span class="n">worst_song</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">worst_song</span> <span class="ow">in</span> <span class="n">sdd</span><span class="p">:</span>
                <span class="n">worst_dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">inversion</span>
                <span class="k">break</span>

            <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">worst_dist</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
            <span class="c"># we could prune pop_list here too,</span>
            <span class="c"># but it showed that one operation only is more effective.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_worst_cache</span> <span class="o">=</span> <span class="n">worst_dist</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># delete the worst one to make place,</span>
        <span class="c"># BUT: do not delete the connection from worst to self</span>
        <span class="c"># we create unidir edges here on purpose.</span>
        <span class="k">del</span> <span class="n">sdd</span><span class="p">[</span><span class="n">worst_song</span><span class="p">]</span>
        <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pop_list</span><span class="p">)</span>

    <span class="c"># Add the new element:</span>
    <span class="n">sdd</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">odd</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>

    <span class="n">inversion</span> <span class="o">=</span> <span class="o">~</span><span class="n">distance</span>
    <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pop_list</span><span class="p">,</span> <span class="p">(</span><span class="n">inversion</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
    <span class="n">heappush</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_pop_list</span><span class="p">,</span> <span class="p">(</span><span class="n">inversion</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

    <span class="c"># Might be something different now:</span>
    <span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
</div>
</div>
<span id="document-rst/V/index"></span><div class="section" id="implizites-und-explizites-lernen">
<h2>5 Implizites und explizites Lernen<a class="headerlink" href="#implizites-und-explizites-lernen" title="Permalink to this headline">¶</a></h2>
<p>Assoziationsregeln...</p>
<div class="math">
\[Rating(A, B) = (1.0 - Kulczynski(A, B)) \cdot ImbalanceRatio(A, B)\]</div>
<p><em>wobei:</em> <a href="#id2"><span class="problematic" id="id3">|hfill|</span></a> <em>Aussagekraft:</em></p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(Kulczynski(A, B) =  \frac{p(A \vert B) + p(B \vert A)}{2}\)</span> <a href="#id4"><span class="problematic" id="id5">|hfill|</span></a> Güte der Regel</li>
<li><span class="math">\(ImbalanceRatio(A, B) = \frac{\vert support(A) - support(B) \vert}{support(A) + support(B) - support(A \cup B)}\)</span> <a href="#id6"><span class="problematic" id="id7">|hfill|</span></a> Gleichmäßigkeit der Regel</li>
<li><span class="math">\(support(X) = H_n(X)\)</span> <a href="#id8"><span class="problematic" id="id9">|hfill|</span></a>  Absolute Häufigkeit von X in allen Transaktionen</li>
</ul>
</div></blockquote>
<p>Mehr dazu in der Bachelorarbeit.</p>
<p><em>Vergleiche zudem:</em> <a class="reference internal" href="rst/index.html#datamining-concepts-and-techniques" id="id1">[1]</a> Datamining
Concepts and Techniques.</p>
</div>
<span id="document-rst/VI/index"></span><div class="section" id="evaluation">
<h2>6 Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="allgemeine-hinweise-fur-entwickler">
<h3>6.1 Allgemeine Hinweise für Entwickler<a class="headerlink" href="#allgemeine-hinweise-fur-entwickler" title="Permalink to this headline">¶</a></h3>
<p>TODO: Tipps zum schreiben einer distanzfunktion für libmunin -&gt; Evalulation</p>
</div>
<div class="section" id="vergleich-verschiedener-playlisten">
<h3>6.2 Vergleich verschiedener Playlisten<a class="headerlink" href="#vergleich-verschiedener-playlisten" title="Permalink to this headline">¶</a></h3>
<p>...</p>
</div>
</div>
<span id="document-rst/VII/index"></span><div class="section" id="zusammenfassung">
<h2>7 Zusammenfassung<a class="headerlink" href="#zusammenfassung" title="Permalink to this headline">¶</a></h2>
<div class="section" id="verbesserung-der-algorithmik">
<h3>7.1 Verbesserung der Algorithmik<a class="headerlink" href="#verbesserung-der-algorithmik" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Rumspinnen über aubio, was möglich ist und wie.</li>
</ul>
</div>
<div class="section" id="erweiterung-der-algorithm">
<h3>7.2 Erweiterung der Algorithm<a class="headerlink" href="#erweiterung-der-algorithm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Keyword extraction auch von amazon reviews.
oft werden vergleiche gezogen.</li>
</ul>
</div>
<div class="section" id="probleme-aktueller-algorithmen">
<h3>7.3 Probleme aktueller Algorithmen<a class="headerlink" href="#probleme-aktueller-algorithmen" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>moodbar solle freqbar heißen</li>
<li>bpm liefert schlechte werte.</li>
</ul>
</div>
<div class="section" id="vergleich-von-zufalligen-playlisten-mit-libmunins-playlisten-mit-last-fm-playlists">
<h3>7.4 Vergleich von zufälligen Playlisten mit libmunins Playlisten mit last.fm playlists<a class="headerlink" href="#vergleich-von-zufalligen-playlisten-mit-libmunins-playlisten-mit-last-fm-playlists" title="Permalink to this headline">¶</a></h3>
<p>subfigure mit gegenüberstellung von &nbsp;15 liedern zu seed song, diskussion.</p>
<ul class="simple">
<li><a class="reference external" href="http://www2.research.att.com/~yifanhu/MusicMap/index.html">http://www2.research.att.com/&nbsp;yifanhu/MusicMap/index.html</a></li>
<li>Suchengine für natürliche Sprache wie in <a class="reference internal" href="rst/index.html#knees2007music" id="id1">[2]</a></li>
<li>Transitions. Beispieslweise immer &quot;härter werdende musik&quot;</li>
<li>Beziehen und Nutzen weiterer Metadaten (wie Producer, Band-Member)</li>
<li>Auch &quot;disklikes&quot; berücksichtigen (zB. songs die immer gleich geskippt wurden)?</li>
<li>Gemeinsame Nachbarn betrachten bei mehreren Seedsongs.</li>
<li>Similar Artist/Album/Genre...</li>
<li>Einbeziehung der duration als provider/distanz (statistisch untersuchen)</li>
<li>(Amazon) artist/album reviews mit einbeziehen, keyword-extraction.</li>
<li>Sprache, Intros und Audio intelligent unterscheiden.</li>
<li>beschleunigter audioanalyse.</li>
<li>date origin abhängig vom genre</li>
<li>genre-bridges: grunge-&gt;rock</li>
</ul>
</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">orphan:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p><strong>Abkürzungsverzeichnis</strong></p>
<div class="figure align-center">
<center><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="headalign-center align-top">Abkürzung</th>
<th class="headalign-center align-top">Bedeutung</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td class="align-center align-top">API</td>
<td class="align-center align-top"><em>Application Programming Interface</em></td>
</tr>
<tr class="row-odd"><td class="align-center align-top">GUI</td>
<td class="align-center align-top"><em>Graphical User Interface</em></td>
</tr>
<tr class="row-even"><td class="align-center align-top">LoC</td>
<td class="align-center align-top"><em>Lines of Code</em></td>
</tr>
<tr class="row-odd"><td class="align-center align-top">ID</td>
<td class="align-center align-top"><em>Identifier</em></td>
</tr>
<tr class="row-even"><td class="align-center align-top">UID</td>
<td class="align-center align-top"><em>Unique Identifier</em></td>
</tr>
</tbody>
</table>
</center></div><div class="toctree-wrapper compound">
<span id="document-rst/appendix"></span><div class="section" id="graphenbilder">
<h2>Graphenbilder<a class="headerlink" href="#graphenbilder" title="Permalink to this headline">¶</a></h2>
<p>Beschreibung</p>
<div class="figure compound align-center" id="fig-graph-linear">
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-basic">
<a class="reference internal image-reference" href="../../_images/graph_linear_basic.png"><img alt="basic" src="../../_images/graph_linear_basic.png" style="width: 100%;" /></a>
<p class="caption">Nur mit <tt class="docutils literal"><span class="pre">sliding_window</span></tt> behandelte Eingabe.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-all">
<a class="reference internal image-reference" href="../../_images/graph_linear_all.png"><img alt="all" src="../../_images/graph_linear_all.png" style="width: 100%;" /></a>
<p class="caption">Zusätzlich mit <tt class="docutils literal"><span class="pre">centering_window</span></tt> und <tt class="docutils literal"><span class="pre">anti_centering_window</span></tt> behandelt.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-refine">
<a class="reference internal image-reference" href="../../_images/graph_linear_refine.png"><img alt="refine" src="../../_images/graph_linear_refine.png" style="width: 100%;" /></a>
<p class="caption">Zusätzliche Verfeinerungsphase.</p>
</div>
<div style="width: 47.5%" class="subfigure align-center" id="fig-graph-linear-stupid">
<a class="reference internal image-reference" href="../../_images/graph_linear_stupid.png"><img alt="stupid" src="../../_images/graph_linear_stupid.png" style="width: 100%;" /></a>
<p class="caption">Mittels <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt> generierter Vergleichsgraph.</p>
</div>
<p class="caption">Verschiedene Stufen beim Aufbau eines Graphen aus linearen Testdaten. Die
Testdaten bestehen aus den Integern 1 bis 100.  Erwartet wird dabei als
Ausgabe eine lineare Kette von Knoten, wobei jeder Knoten ca. 7 Nachbarn
haben sollte.</p>
</div><div class="figure align-center" id="fig-graph-linear">
<a class="reference internal image-reference" href="../../_images/graph_euler_basic.png"><img alt="Basic" src="../../_images/graph_euler_basic.png" style="width: 100%;" /></a>
<p class="caption">stuff.</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/graph_euler_all.png"><img alt="Basic" src="../../_images/graph_euler_all.png" style="width: 100%;" /></a>
<p class="caption">stuff.</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/graph_euler_refine.png"><img alt="Basic" src="../../_images/graph_euler_refine.png" style="width: 100%;" /></a>
<p class="caption">stuff.</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/graph_euler_stupid.png"><img alt="Basic" src="../../_images/graph_euler_stupid.png" style="width: 100%;" /></a>
<p class="caption">stuff.</p>
</div>
</div>
<div class="section" id="bilder-des-genregraphen">
<h2>Bilder des Genregraphen<a class="headerlink" href="#bilder-des-genregraphen" title="Permalink to this headline">¶</a></h2>
<p>Beschreibung.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_big.svg"><img alt="Basic" src="../../_images/genre_graph_big.svg" width="100%" /></a>
<p class="caption">stuff.</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_mid.svg"><img alt="Basic" src="../../_images/genre_graph_mid.svg" width="100%" /></a>
<p class="caption">stuff.</p>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/genre_graph_min.svg"><img alt="Basic" src="../../_images/genre_graph_min.svg" width="100%" /></a>
<p class="caption">stuff.</p>
</div>
</div>
<div class="section" id="anhang-c">
<h2>Anhang C<a class="headerlink" href="#anhang-c" title="Permalink to this headline">¶</a></h2>
<p>Bye cruel world.</p>
</div>
<span id="document-rst/zzz_bibliography"></span><div class="section" id="bibliographie">
<h2>Bibliographie<a class="headerlink" href="#bibliographie" title="Permalink to this headline">¶</a></h2>
</div>
<p id="bibtex-bibliography-rst/zzz_bibliography-0"><table class="docutils citation" frame="void" id="datamining-concepts-and-techniques" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Jian&nbsp;Pei Jiawei&nbsp;Han, Micheline&nbsp;Kamber. Datamining - concepts and techniques, (3rd edition). In <em>Datamining - Concepts and Techniques</em>, 268–271. 2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="knees2007music" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Peter Knees, Tim Pohle, Markus Schedl, and Gerhard Widmer. A music search engine built upon audio-based and web-based similarity measures. In <em>Proceedings of the 30th annual international ACM SIGIR conference on Research and development in information retrieval</em>, 447–454. ACM, 2007.</td></tr>
</tbody>
</table>
</p>
<div class="section" id="weblink-verzeichnis">
<h2>Weblink Verzeichnis<a class="headerlink" href="#weblink-verzeichnis" title="Permalink to this headline">¶</a></h2>
</div>
<p id="bibtex-bibliography-rst/zzz_bibliography-1"></p>
</div>
<div class="section" id="lizenz">
<h2>Lizenz<a class="headerlink" href="#lizenz" title="Permalink to this headline">¶</a></h2>
<p>Diese Arbeit ist unter den Bedingungen der <em>Creative Commons Attribution-3.0</em>
lizensiert:</p>
<blockquote>
<div><a class="reference external" href="http://creativecommons.org/licenses/by/3.0/de/">http://creativecommons.org/licenses/by/3.0/de/</a></div></blockquote>
<a class="reference internal image-reference" href="../../_images/cclogo.svg"><div align="center" class="align-center"><img alt="Creative Commons License" src="../../_images/cclogo.svg" width="50%" /></div>
</a>
</div>
</div>


          <footer>
  

  <hr/>

  <p>
      &copy; Copyright by Christopher Pahl, 2013-2014..
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>