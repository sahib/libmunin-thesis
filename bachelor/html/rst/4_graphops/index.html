

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4 Graphenoperationen &mdash; Projektarbeit</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Projektarbeit" href="../../index.html"/>
        <link rel="next" title="5 Algorithmen bei Providern" href="../5_provider/index.html"/>
        <link rel="prev" title="3 Allgemeine Entwicklerhinweise" href="../3_einleitung/index.html"/>

<!-- Include all CSS and JS files, let's you use your own theme. -->

<link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
<script type="text/javascript">
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}

    $(document).ready(function() {
    	var im, imsrc;
    	$('img').each(function() {
    		im = $(this);
    		imsrc = im.attr('src');
    		imalt = im.attr('alt');
    		if (endsWith(imsrc, 'svg')) {
    			im.wrap($('<a>').attr({'href': imsrc, 'title': imalt}).addClass('svglink'));
    		}
    	});

    	$('a.svglink').colorbox({
    		'width': '95%',
    		'height': '95%',
    		'photo': true});
    });
</script>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="fa fa-home"> Projektarbeit</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../abstract.html">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acknowledgements.html">Danksagung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dedication.html">Widmung</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1_intro/index.html">1 Überleitung</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1_intro/index.html#das-allgemeine-problem">1.1 Das allgemeine Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1_intro/index.html#das-konkrete-problem">1.2 Das konkrete Problem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2_begriffe/index.html">2 Begriffsklärungen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2_begriffe/index.html#allgemeine-fachbegriffe">2.1 Allgemeine Fachbegriffe</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2_begriffe/index.html#kontextspezifische-fachbegriffe">2.2 Kontextspezifische Fachbegriffe</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3_einleitung/index.html">3 Allgemeine Entwicklerhinweise</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3_einleitung/index.html#zur-nuztung-von-libmunin">3.1 Zur Nuztung von <em>libmunin</em></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3_einleitung/index.html#zur-erweiterung-von-libmunin">3.2 Zur Erweiterung von <em>libmunin</em></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3_einleitung/index.html#vergleich-verschiedener-playlisten">3.3 Vergleich verschiedener Playlisten</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3_einleitung/index.html#ressourcenverbrauch">3.4 Ressourcenverbrauch</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">4 Graphenoperationen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">4.1 Graphenoperationen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graphentraversierung">4.2 Graphentraversierung</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5_provider/index.html">5 Algorithmen bei Providern</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5_provider/index.html#einleitung">5.1 Einleitung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5_provider/index.html#genre-normalisierung-und-vergleich">5.2 Genre-Normalisierung und Vergleich</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5_provider/index.html#schlusselwortextraktion">5.3 Schlüsselwortextraktion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5_provider/index.html#moodbar">5.4 Moodbar</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6_learning/index.html">6 Implizites Lernen vom Nutzer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6_learning/index.html#generierung-von-regeln">6.1 Generierung von Regeln</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6_learning/index.html#anwendung-von-regeln">6.2 Anwendung von Regeln</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6_learning/index.html#lernerfolg">6.3 Lernerfolg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6_learning/index.html#explizites-lernen">6.4 Explizites Lernen</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7_outro/index.html">7 Ausblick</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7_outro/index.html#verbesserung-der-algorithmik">7.1 Verbesserung der Algorithmik</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7_outro/index.html#erweiterungen">7.2 Erweiterungen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7_outro/index.html#fazit">7.3 Fazit</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix.html">Bilder des Song&ndash;Graphen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix.html#allgemeine-hinweise">Allgemeine Hinweise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix.html#plotting-der-graphen">Plotting der Graphen</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix.html#bilder-des-genregraphen">Bilder des Genregraphen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix.html#medien">Medien</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzz_bibliography.html">Bibliographie</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzz_bibliography.html#weblink-verzeichnis">Weblink Verzeichnis</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Projektarbeit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>4 Graphenoperationen</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/rst/4_graphops/index.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="graphenoperationen">
<h1>4 Graphenoperationen<a class="headerlink" href="#graphenoperationen" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>4.1 Graphenoperationen<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Eine grobe Übersicht über die einzelnen Graphenoperationen und ihrer
Zuständigkeiten wurde bereits in der Projektarbeit gegeben. Im Folgenden
wird detailliert auf ihre Funktionsweise und Internas eingegangen.</p>
<div class="section" id="rebuild-aufbau-des-graphen">
<h3>4.1.1 <tt class="docutils literal"><span class="pre">rebuild:</span></tt> Aufbau des Graphen<a class="headerlink" href="#rebuild-aufbau-des-graphen" title="Permalink to this headline">¶</a></h3>
<p>Bevor irgendeine andere Operation ausgeführt werden kann muss mittels der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation der Graph aufgebaut werden. Wie bereits in der
Projektarbeit erwähnt, kann der Graph aufgrund von einer Komplexität von
<span class="math">\(O(n2)\)</span> nicht einfach durch das Vergleichen aller Songs untereinander
erfolgend. Daher muss eine Lösung mit subquadratischen Aufwand gefunden werden.
Vorzugsweise eine, bei der Rechenaufwand gegen die Qualität der Approximation
abgewägt werden kann.  So kann der Nutzer entscheiden wie lange er <em>libmunin</em>
rechnen lassen will.</p>
<p>Der Ausgangszustand der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operationen ist eine Liste von Songs die
vom Nutzer bereitgestellt wird. Jeder Song darin soll nun so im Graphen
platziert werden, dass er im Bestfall die ähnlichsten Songs als Nachbarn hat.</p>
<p>Jeder Song speichert seine Nachbarn mit der dazugehörigen Distanz.  Soll ein
neuer Nachbar hinzugefügt werden, so wird geprüft ob die Distanz zu diesem neuen
Song besser ist als die zum schlechtesten vorhandenen Nachbar.  Ist dies der
Fall, so wird die Entfernung zu diesem schlechtesten Nachbarn <em>in eine Richtung</em>
(die Gründe hierfür werden unter <a class="reference internal" href="#ref-distance-add">4.1.7</a> betrachtet) gekappt.
Als Ersatz wird zu dem neuen, besseren Song eine bidirektionale Verbindung
aufgebaut. Da die Verbindung zum schlechtesten Song nur unidirektional abgebaut
wird, ist die Anzahl der Nachbarn eines Songs nicht auf einen Maximum begrenzt,
da das Hinzufügen neuer Songs <em>,,Einbahnstraßen&quot;</em> hinterlässt.</p>
<p>Vielmehr handelt es sich dabei um einen Richtwert, um den sich die tatsächliche
Anzahl der Songs einpendeln wird. Momentan ist dieser Richtwert standardmäßig
auf <span class="math">\(15\)</span> gesetzt &mdash; der durchschnittlichen Länge eines heutigen Albums
plus eins <a class="footnote-reference" href="#f1" id="id2"><sup>1</sup></a>. Dieser Wert hat sich nach einigen Tests als passable erwiesen.
Bei zu niedrigen Werten verbinden sich die einzelnen Alben nur untereinander,
bei zu hohen entstehen zu viele qualitativ schlechte Verbindungen quer über den
ganzen Graphen.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Bestimmt an der persönlichen Sammlung des Autors. Bei 1590 einzelnen
Alben ist dieser Wert exakt <span class="math">\(14.1427\)</span>.</td></tr>
</tbody>
</table>
<p>Wenn im folgenden vom <em>,,Berechnen der Distanz&quot;</em> gesprochen wird, so ist damit</p>
<div class="figure compound align-center" id="fig-windows">
<div style="width: 50%" class="subfigure align-center" id="fig-window-sliding">
<a class="reference internal image-reference" href="../../_images/sliding_window.svg"><img alt="Schematische Darstellung des sliding_window." src="../../_images/sliding_window.svg" width="100%" /></a>
<p class="caption"><strong>(a)</strong> Darstellung des sliding_window.</p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-centering">
<a class="reference internal image-reference" href="../../_images/centering_window.svg"><img alt="Schematische Darstellung des centering_window." src="../../_images/centering_window.svg" width="100%" /></a>
<p class="caption"><strong>(b)</strong> Darstellung des centering_window.</p>
</div>
<div style="width: 50%" class="subfigure align-center" id="fig-window-anti-centering">
<a class="reference internal image-reference" href="../../_images/anti_centering_window.svg"><img alt="Schematische Darstellung des anti_centering_window." src="../../_images/anti_centering_window.svg" width="100%" /></a>
<p class="caption"><strong>(c)</strong> Darstellung des anti_centering_window.</p>
</div>
<p class="caption"><strong>Figure 4.1:</strong> Schematische Darstellungen der einzelnen Basisiterationen. Es werden jeweils
drei Iterationen in einem Bild dargestellt. Das Fenster in der ersten
Iteration ist dabei jeweils grün, in der zweiten gelb und in der letzten rot
dargegestellt. Die Zahlen repräsentieren einzelne Songs.</p>
</div><p id="fig-windows">Im Folgenden werden die drei Schritte der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation genauer
beleuchtet:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Für jeden Song wird nach willkürlich festgelegten
Prinzipien eine kleine Menge von möglicherweise ähnlicher Songs ausgewählt.
Diese Menge von Songs wird untereinander mit quadratischen Aufwand verglichen.
Diese Vorgehensweise wird mehrmals mit verschiedener Methoden wiederholt. Das
Ziel jeder dieser Iterationen ist es für einen Song zumindestens eine kleine
Anzahl von ähnlichen Songs zu finden. Basierend auf diesen wird in den
nächsten Schritten versucht die Anzahl ähnlicher Songs zu vergrößern.</p>
<p>Momentan sind drei verschiedene Iterationsstrategien implementiert. Jede
basiert auf gewissen heuristischen Annahmen die über die Eingabemenge gemacht
wird:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">sliding_window:</span></tt> Schiebt ein <em>,,Fenster&quot;</em> über die Liste der Songs.
Alle Songs innerhalb des Fensters werden untereinander verglichen.  Die
Fenstergröße ist dabei konfigurierbar und ist standardmäßig auf 60
eingestellt, da sich diese Größe nach einigen Tests als guter Kompromiss
zwischen Qualität und Geschwindigkeit herausgestellt hat.  Bei jeder
Iteration wird das Fenster um ein Drittel der Fenstergröße
weitergeschoben.  Dadurch entsteht eine <em>,,Kette&quot;</em> von zusammenhängenden
Songs.</p>
<p>Die heuristische Annahme ist dabei, dass der Nutzer der Bibliothek seine
Datenbank meist nach Alben sortiert eingibt. Durch diese Sortierung finden
sich innerhalb eines Fensters oft Lieder des selben Albums &mdash; diese  sind
oft sehr ähnlich.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">centering_window:</span></tt> Basiert ebenfalls auf einem Fenster. Im Gegensatz
zum obigen <tt class="docutils literal"><span class="pre">sliding_window</span></tt> besteht das Fenster allerdings aus zwei
Hälften, wobei die eine vom Anfang an startet und die andere Hälfte von
der Mitte aus bis zum Ende geschoben wird. Die Songs in beiden Hälften
werden analog zu oben untereinander verglichen. Auch hier überlappen sich
die einzelnen Hälften zu je zwei Drittel.</p>
<p>Die heuristische Annahme ist hier, dass in der bereits vorhandenen
<em>,,Kette&quot;</em> Querverbindungen hergestellt werden. Dies ist den nächsten
Schritten vorteilhaft um Iterationen einzusparen.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">anti_centering_window:</span></tt> Sehr ähnlich zum <tt class="docutils literal"><span class="pre">centering_window</span></tt>, statt
die zwei Hälfte aber von der Mitte aus bis zum Ende weiter zu schieben
wird diese vom Ende zur Mitte geschoben. So werden die beiden Hälften
solange weiter geschoben, bis sie sich in er Mitte treffen.</p>
<p>Auch hier sollen weitere Querverbindungen hergestellt werden.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Um den momentan sehr grob vernetzten Graphen benutzbar zu
machen müssen einige Iterationen zur <em>,,Verfeinerung&quot;</em> durchgeführt werden.
Dabei wird über jeden Song im Graphen iteriert und dessen <em>indirekte Nachbarn</em>
(also die Nachbarn der direkten Nachbarsongs) werden mit dem aktuellen Song
verglichen. Kommen dabei Distanzen zustande, die niedriger sind als die der
aktuellen Nachbarn, wird der indirekte Nachbar zum direkten Nachbarn. Auf
diese Weise rücken ähnliche Songs immer weiter aufeinander zu.
Diese Vorgehensweise wird solange wiederholt bis nur noch eine geringe Anzahl
von Songs <em>,,bewegt&quot;</em> oder bis eine maximale Anzahl von Iterationen erreicht
ist. Die Begrenzung der Iterationen ist nötig, da es Fälle geben kann in denen
einzelne Songs immer wieder zwischen zwei gleich guten Zuständen hin- und
herspringen können.</p>
<p>Als zusätzliche Optimierung werden nicht alle indirekten Nachbarn betrachtet,
sondern nur diese, zu denen der Weg eine gewisse <em>Mindestdistanz</em> nicht
unterschreitet. Diese Mindestdistanz wird beim Start auf <span class="math">\(2.0\)</span> (da ja
die Distanz über zwei Kanten gemessen wird) gesetzt und während der folgenden
Iterationen immer weiter abgesenkt.</p>
<p>Die Gesetzmäßigkeit, nach der die Mindesdistanz immer weiter abgesenkt wird,
berechnet sich dabei aus dem arithmetischen Mittelwert, der bis dahin
berechneten Distanzen. Ist der Mittelwert hoch, so ist die Absenkung klein.</p>
</li>
<li><p class="first"><strong>Aufräumearbeiten:</strong> Nach dem Verfeinerungsschritt wird der Graph von
Einbahnstraßen durch einen <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt bereinigt und auf Konsistenz
geprüft.</p>
</li>
</ul>
<p>Wie bereits erwähnt gibt es eine <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt>&ndash;Operation, welche für
deutlich kleinere Mengen von Songs praktikabel einsetzbar ist. Die Algorithmik
ist hierbei bedeutend einfacher: Es wird einfach jeder Song mit jedem anderen
verglichen. Als Nachbarn erhält dabei jeder Song die Nachbarn, die global
betrachtet die kleinste Distanz zu diesem besitzen. Es handelt sich als um keine
Approximation wie beim herkömmlichen <tt class="docutils literal"><span class="pre">rebuild</span></tt>.</p>
<p>Auf die Betrachtung der Komplexität der <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation wird an dieser
Stelle verzichtet. Keine der einzelnen Schritte erreicht dabei quadratische
Komplexität.  Die einzige Ausnahme ist dabei das Vergleichen der Songs
untereinander innerhalb eines Fensters, allerdings ist dabei  die Fenstergröße
stets auf ein verträgliches Limit begrenzt.</p>
<p>Unter Abb.  findet sich eine Gegenüberstellung von den
Aufrufen der Distanzfunktion, die bei <tt class="docutils literal"><span class="pre">rebuild_stupid</span></tt> und beim normalen
<tt class="docutils literal"><span class="pre">rebuild</span></tt> (mit und ohne <em>Verfeinerungsschritt</em>) nötig sind.</p>
<div class="figure align-center" id="fig-speed-cmp">
<a class="reference internal image-reference" href="../../_images/graph_speed.svg"><img alt="Vergleich der Distanzberechnungen für rebuild_stupid und rebuild." src="../../_images/graph_speed.svg" width="100%" /></a>
<p class="caption"><strong>Figure 4.2:</strong> Gegenüberstellung von verschiedenen Arten der rebuild&ndash;Operation. Auf der
Y&ndash;Achse ist logarithmisch die Anzahl der Distanzberechnungen aufgetragen,
auf der X&ndash;Achse die lineare Anazhl der Eingabesongs. Die blaue Kurve
repräsentiert dabei die Vergleiche die für rebuild_stupid notwendig sind.
Wie man sieht, übersteigen diese bis auf dem Gleichheitsbereich am Anfang die
anderen zwei Kurven deutlich.</p>
</div>
<p>Die einzelnen Schritte des Graphenaufbaus lassen sich in Abb.
, sowie bei den darauf folgenden Abbildungen,
nachvollziehen.</p>
</div>
<div class="section" id="fixing-umbauen-von-einbahnstraszen">
<h3>4.1.2 <tt class="docutils literal"><span class="pre">fixing:</span></tt> Umbauen von Einbahnstraßen<a class="headerlink" href="#fixing-umbauen-von-einbahnstraszen" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation dient dem Entfernen von Einbahnstraßen innerhalb des Graphen.
Einbahnstraßen können wie bereits erwähnt beim Hinzufügen neuer Distanzen
entstehen.</p>
<p>Beim Entfernen wird folgendermaßen vorgegangen: Im ersten Schritt werden alle
unidirektionalen Kanten gefunden und abgespeichert. Für jede dieser Kanten wird
überprüft ob die Songs an beiden Enden den Richtwert für die Anzahl der Nachbarn
überschreitet. Sollte das nicht der Fall, so wird die Kante in eine
bidirektionale Kante umgebaut. Andernfalls wird die Kante gelöscht.</p>
<p>Dieses Vorgehen wurde gewählt weil es nach einigen Versuchen schwierig erschien,
den Graphen ohne Einbahnstraßen aufzubauen, ohne dass dieser zur Inselbildung
neigt. Durch den nachgelagerten <tt class="docutils literal"><span class="pre">fixing</span></tt>&ndash;Schritt werden Songs die nur wenige
Nachbarn besitzen durch die vorher als zu schlecht bewerteten Kanten verbunden.</p>
<p>Als zusätzliche Konsistenzprüfung wird nach dem Bereinigen geprüft, ob alle
Verbindungen im Graphen bidirektional sind. Sollten unidirektionale Kanten
gefunden werden, so wird eine Warnung ausgegeben. Eine weiterführende
Fehlerbehandlung ist momentan noch nicht implementiert. Unidirektionale Kanten
können bei der Traversierung zu Ausnahmefehlern führen.</p>
</div>
<div class="section" id="add-hinzufugen-von-songs-vor-dem-rebuild">
<h3>4.1.3 <tt class="docutils literal"><span class="pre">add:</span></tt> Hinzufügen von Songs vor dem <tt class="docutils literal"><span class="pre">rebuild</span></tt><a class="headerlink" href="#add-hinzufugen-von-songs-vor-dem-rebuild" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation benötigt als Argument eine Hashtabelle mit einer Abbildung von
Attributen auf Werte. Diese Werte werden dann, wie in der Projekarbeit
besprochen, durch verschiedene Provider normalisiert. Mit diesen normalisierten
Informationen wird dann eine neue Song&ndash;Instanz erzeugt, welcher beim Erzeugen
ein eindeutiger Identifier zugewiesen wird. Dieser Identifier dient dann als
Index in der internen Songliste.
Statt wie <tt class="docutils literal"><span class="pre">insert</span></tt> bereits Verbindungen zu anderen Songs herzustellen, fügt
diese Operation lediglich einen Song der internen Songliste hinzu.</p>
<div class="figure compound align-center" id="fig-mini-graph-remove">
<span id="fig-mini-graph-remove-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-remove-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_remove_before.png"><img alt="../../_images/mini_graph_remove_before.png" src="../../_images/mini_graph_remove_before.png" style="width: 50%;" /></a>
<p class="caption"><strong>(a)</strong> Vor der remove&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_remove_after.png"><img alt="../../_images/mini_graph_remove_after.png" src="../../_images/mini_graph_remove_after.png" style="width: 50%;" /></a>
<p class="caption">Nach der remove&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der remove&ndash;Operation.</p>
<span class="target" id="fig-mini-graph-remove"></span></div><div class="figure compound align-center" id="fig-mini-graph-insert">
<span id="fig-mini-graph-insert-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-insert-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_insert_before.png"><img alt="../../_images/mini_graph_insert_before.png" src="../../_images/mini_graph_insert_before.png" style="width: 50%;" /></a>
<p class="caption">Vor der insert&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_insert_after.png"><img alt="../../_images/mini_graph_insert_after.png" src="../../_images/mini_graph_insert_after.png" style="width: 50%;" /></a>
<p class="caption">Nach der insert&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der insert&ndash;Operation.</p>
<span class="target" id="fig-mini-graph-insert"></span></div><div class="figure compound align-center" id="fig-mini-graph-modify">
<span id="fig-mini-graph-modify-after"></span><div style="width: 49%" class="subfigure align-center" id="fig-mini-graph-modify-before">
<a class="reference internal image-reference" href="../../_images/mini_graph_modify_before.png"><img alt="../../_images/mini_graph_modify_before.png" src="../../_images/mini_graph_modify_before.png" style="width: 60%;" /></a>
<p class="caption">Vor der modify&ndash;Operation.</p>
</div>
<div style="width: 49%" class="subfigure align-center">
<a class="reference internal image-reference" href="../../_images/mini_graph_modify_after.png"><img alt="../../_images/mini_graph_modify_after.png" src="../../_images/mini_graph_modify_after.png" style="width: 60%;" /></a>
<p class="caption">Nach der modify&ndash;Operation.</p>
</div>
<p class="caption">Vor () und nach
() der modify&ndash;Operation.
Es wurden jeweils die Mittelknoten der beiden Inseln mit einem höhren Rating
ausgestattet. Dadurch verbinden sich beide und verlieren dafür eine andere
Verbindung jeweils.</p>
<span class="target" id="fig-mini-graph-modify"></span></div></div>
<div class="section" id="remove-loschen-von-songs-zur-laufzeit">
<h3>4.1.4 <tt class="docutils literal"><span class="pre">remove:</span></tt> Löschen von Songs zur Laufzeit<a class="headerlink" href="#remove-loschen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Um nach einer <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation einen Song auf dem Graphen zu löschen,
müssen alle Verbindungen zu diesem entfernt werden.  Um dabei eine Bildung von
Inseln (durch das Entfernen von Verbindungen) zu vermeiden, werden alle
ursprünglichen Nachbarn des zu entfernenden Songs untereinander verbunden. Dabei
wird folgendermaßen vorgegangen: Zuerst wird temporär für jeden Nachbarn den
Richtwert für die Anzahl der Nachbarn um eins erhöht. Im Anschluss wird die
Menge aller Nachbarn untereinander mit quadratischem Aufwand verglichen. Dadurch
bekommt jeder Nachbar, im besten Fall, eine neue Verbindung.  Abschließend werden
alle Verbindungen zum zu löschenden Song entfernt und der Richtwert wird wieder
um eins dekrementiert.</p>
<p>Da <em>libmunin</em> alle Songs in einer linearen List hält muss auch dort der Song
gelöscht werden. Da der Index des Songs in der Liste gleich des <em>Identifiers</em>
des Songs ist, wird an dessen Stelle ein leerer Wert geschrieben. Damit dieser
möglichst bald wieder besetzt wird, wird der gelöschte <em>Identifier&ndash;Index</em> in
einer sogenannten <em>Revocation</em>&ndash;List gespeichert. Beim nächsten <tt class="docutils literal"><span class="pre">add</span></tt> oder
<tt class="docutils literal"><span class="pre">insert</span></tt> wird dieser <em>Identifier</em> dann wiederverwendet. Dieses Verfahren soll
eine Fragementierung der Song&ndash;Liste nach vielen <tt class="docutils literal"><span class="pre">remove</span></tt>&ndash;Operation
vermeiden.</p>
</div>
<div class="section" id="insert-hinzufugen-von-songs-zur-laufzeit">
<span id="ref-graphop-insert"></span><h3>4.1.5 <tt class="docutils literal"><span class="pre">insert:</span></tt> Hinzufügen von Songs zur Laufzeit<a class="headerlink" href="#insert-hinzufugen-von-songs-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation ist äquivalent zu <tt class="docutils literal"><span class="pre">add</span></tt>. Als Erweiterung fügt <tt class="docutils literal"><span class="pre">insert</span></tt>
allerdings den, durch <tt class="docutils literal"><span class="pre">add</span></tt> erzeugten Song auch in den Graphen ein und
verbindet ihn dort. Dazu muss zuerst ein <em>Punkt</em> gefunden werden an dem der Song
passend zu seinen Attributen <em>eingepasst</em> werden kann.</p>
<p>Diese <em>Einpassung</em> geschieht dabei folgendermaßen:</p>
<ul>
<li><p class="first"><strong>Basisiteration:</strong> Es wird mit einer gewissen <em>Schrittweite</em> über die
Songliste iteriert. Dabei werden die Distanzen vom momentan aktuellen Song zum
einzufügenden Song berechnet. Dadurch wird der Song bereits mit einigen
anderen Songs verknüpft.  Die Größe der Schrittweite ist dabei abhängig von
der Länge der Songliste.  Je länger die Liste ist, desto größer ist die
Schrittweite.  Exakt ist sie dabei folgendermaßen definiert:</p>
<div class="math">
\[Schrittweite = \lceil\log_{10}songlist\_length\rceil\]</div>
</li>
<li><p class="first"><strong>Verfeinerung:</strong> Songs, zu denen im vorigen Schritt eine geringe Distanz
gefunden wurde, werden nun detaillierter betrachtet. Dazu wird die Distanz zu
den Nachbarn dieser <em>guten</em> Songs berechnet, unter der bekannten Annahme, dass
die indirekten Nachbar des einzufügenden Songs auch als potenzielle direkte
Nachbarn taugen.</p>
</li>
</ul>
<p>Als zusätzliche Beobachtung lässt sich feststellen, dass Songs die per
<tt class="docutils literal"><span class="pre">insert</span></tt> eingefügt werden deutlich <em>weitläufiger</em> verbunden sind als regulär
per <tt class="docutils literal"><span class="pre">add</span></tt> hinzugefügte. Diese Eigenschaft macht sich die in der Projektarbeit
gezeigte Demonanwedung zu Nutze: Ändert man das <em>Rating</em> eines Songs, so wird
der Song mitels <tt class="docutils literal"><span class="pre">remove</span></tt> gelöscht und mittels  <tt class="docutils literal"><span class="pre">insert</span></tt> anderswo wieder
eingefügt. Meist verbindet sich dabei der Song dann mit anderen ähnlich
bewerteten Songs. Diese bilden ein <em>zusätzliches Netz</em> über den Graphen, welches
weitläufrigere Sprünge ermöglicht.  Dadurch hat der Nutzer eine intuitive
Möglichkeit den Graphen seinen Vorstellungen nach umzubauen (Stichwort
<em>explizites Lernen</em>).</p>
</div>
<div class="section" id="modify-verandern-der-songattribute-zur-laufzeit">
<h3>4.1.6 <tt class="docutils literal"><span class="pre">modify:</span></tt> Verändern der Songattribute zur Laufzeit<a class="headerlink" href="#modify-verandern-der-songattribute-zur-laufzeit" title="Permalink to this headline">¶</a></h3>
<p>Diese Operation dient als Komfortfunktion. Sie ermöglicht das Verändern der
Attribute, beziehungsweise deren zugeordneten Werte, eines einzelnen Songs.
Würde man die Werte eines Songs manuell verändern, so müsste man alle Distanzen
zu diesem Song neu berechnen. Da dies wiederum Veränderungen im ganzen Graphen
hervorrufen könnte, wurden die Song&ndash;Instanzen unveränderbar <em>(,,Immutable&quot;)</em>
gemacht.</p>
<p>Die <tt class="docutils literal"><span class="pre">modify</span></tt>&ndash;Operation umgeht dieses Problem indem es den Song erst durch ein
<tt class="docutils literal"><span class="pre">remove</span></tt> entfernt und eine Kopie des ursprünglichen Songs macht, in der die
neuen Werte gesetzt werden. Dieser neue, noch unverbundene Song wird dann
mittels einer <tt class="docutils literal"><span class="pre">insert</span></tt>&ndash;Operation in den Graphen eingepasst.</p>
<p>Aufgrund dieser Abfolge unterschiedlicher Operation ist <tt class="docutils literal"><span class="pre">modify</span></tt> relativ
aufwendig. Es wird empfohlen diese Operation nur für einzelne Song jeweils
einzusetzen. Sollte ein bestimmtes Attribut in allen Songs geändert werden, so
ist eine <tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation zu empfehlen.</p>
</div>
<div class="section" id="ablauf-beim-hinzufugen-einer-distanz">
<span id="ref-distance-add"></span><h3>4.1.7 Ablauf beim Hinzufügen einer Distanz<a class="headerlink" href="#ablauf-beim-hinzufugen-einer-distanz" title="Permalink to this headline">¶</a></h3>
<p>Wie bereits erwähnt speichert jeder Song eine Hashtabelle mit den jeweiligen
Songs, zu denen er eine Verbindung hält, als Schlüssel und der Distanz als Wert.</p>
<p>Um diese Hashtabelle zu füllen ist eine Funktion nötig, die sich nach näherer
Betrachtung als relativ schwierig zu implementieren gestaltete. Tatsächlich
wurden an die 2 Wochen mit unterschiedlichen Herangehensweisen verbracht.</p>
<p>Die Anzahl von Nachbarn pro Song sollte sich um einen gewissen <em>Richtwert</em>
einpendeln, den man konfigurieren kann. Daraus folgt, dass bei zu vielen
Nachbarn der <em>schlechteste Nachbarn</em> entfernt werden muss. Der anfängliche
Versuch die Verbindung zwischen den beiden Songs komplett zu löschen hatte aber
ein gewichtiges Problem: Die Inseln im Graphen, die jeweils ein Album
repräsentierten, haben sich nur untereinander verbunden. Verbindungen dazwischen
wurden immer wieder als der <em>schlechteste Nachbar</em> erkannt und entfernt. Daher
neigt der entstehende Graph stark zur Inselbildung und Bildung von starken
Clustern.</p>
<p>Die momentan Lösung ist dabei, dass der schlechteste Nachbar eine
unidirektionale Verbindung zu seinem ursprünglichen Partner aufrecht erhält. Die
Verbindung wird als nicht bidirektional gelöscht. Der Trick ist dabei: Bei der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation werden diese <em>Einbahnstraßen</em> immer noch von einer Seite
als Nachbarn erkannt. So kann insbesondere der <em>Verfeinerungsschritt</em> gut
zueinander passende Songs näher aneinander ziehen. Nach dem <tt class="docutils literal"><span class="pre">rebuild</span></tt> werden
übrig gebliebene Einbahnstraßen in normale Verbindungen umgebaut oder, falls
beide Enden der Verbindung bereits <em>,,voll&quot;</em> sind, gelöscht. So bleiben Songs,
zu denen kein passender Partner gefunden wurde, mit dem Rest des Graphen
verbunden.</p>
<p>Dieses Vorgehen bringt aber bereits einige algorithmische Probleme mit sich: Das
Finden des schlechtesten Nachbarn würde jeweils linearen Aufwand zum Iterieren
über die Hashtabelle erfordern.  Zwar kann dann die schlechteste Distanz und der
dazugehörige Song zwischengespeichert werden, doch nach einigen Tests stellte
sich heraus, dass in den meisten Fällen ein neuer, schlechtester Song gesucht
werden muss. Das ist damit zu erklären, dass gegen Ende der
<tt class="docutils literal"><span class="pre">rebuild</span></tt>&ndash;Operation tendenziell immer niedrigere Distanzen gefunden werden
&mdash; womit immer wieder der schlechteste Song herausgelöscht werden muss.</p>
<p>Der momentane Ansatz speichert pro Song, neben der Hashtabelle mit den
Distanzen, auch einen Heap als <em>,,Lookup&ndash;Hilfe&quot;</em>.</p>
<p>In diesem werden, entgegen der natürlichen Unordnung in einer Hastabelle, die
zuletzt hinzugefügten Paare aus Distanzen und Songs partiell sortiert abgelegt.
Gemäß der Natur eines Heaps, ist dabei der Wurzelknoten immer das Element mit
der größten Distanz.  Ist es dann nötig eine neue, schlechteste Distanz zu
finden, so kann mit einem Aufwand von <span class="math">\(O(\log n)\)</span> das oberste Paar
herausgenommen werden.</p>
<p>Die <tt class="docutils literal"><span class="pre">distance_add()</span></tt> Funktion nimmt 3 Parameter. Die ersten zwei sind die
Songs (im Folgenden <em>A</em> und <em>B</em>), zwischen denen eine Verbindung hergestellt
werden soll. Der letzte ist die Distanz mit der diese Kante gewichtet wird.  Im
Folgenden ist der Code in gekürzter, vereinfachter Form als Referenz gegeben:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">distance_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Füge eine Kante zwischen zwei Songs mit einer Distanz hinzu.</span>

<span class="sd">    self, other: Die beiden Songs zwischen denen die Kante hergestellt werden soll.</span>
<span class="sd">    distance: Die Distanz dieser Kante.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c"># Selbe Referenz! Kann Endlosschleifen verursachen.</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">&lt;</span> <span class="n">distance</span> <span class="ow">and</span> <span class="n">song</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
        <span class="k">return</span>  <span class="c"># worst_cache ist die gespeicherte schlechteste Distanz oder None.</span>

    <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c"># Distanz zu diesem Song war bereits vorhanden und besser.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">return</span>  <span class="c">#  Da other bereits enthalten: Einfach updaten.</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>  <span class="c"># Finde den schlechtesten Nachbarn der noch valide ist.</span>
            <span class="n">worst_dist</span><span class="p">,</span> <span class="n">worst_song</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># Wurzelknoten</span>
            <span class="k">if</span> <span class="n">worst_song</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span>  <span class="c"># Probiere nächstes Element.</span>

        <span class="k">if</span> <span class="n">worst_dist</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="n">worst_dist</span>
            <span class="k">return</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">worst_song</span><span class="p">]</span>
        <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span>

    <span class="c"># Füge neue Kante in die Hashtabellen ein:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dist_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>

    <span class="c"># Speichere die Paare im Heap ab:</span>
    <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
    <span class="n">heappush</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">worst_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># Hat sich möglicherweise geändert.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="graphentraversierung">
<h2>4.2 Graphentraversierung<a class="headerlink" href="#graphentraversierung" title="Permalink to this headline">¶</a></h2>
<p>Um nun tatsächlich Empfehlungen abzuleiten muss der Graph traversiert werden.
Je nach Art der Anfrage werden ein oder mehrere <em>Zentren</em> für eine Breitensuche,
sogenannte <em>Seedsongs</em>, ausgewählt. Bei einfachen Anfragen in der Art <em>,,Gib
10 ähnliche zu Song X aus&quot;</em>, kann einfach der Song <em>X</em> als Seedsong angenommen
werden. Komplexere Anfragen wie <em>,,Gib 10 Songs die ein Genre ähnlich Y
haben aus&quot;</em> oder <em>,,Empfiehl mir 10 Songs basierend auf dem Nutzerverhalten</em>&quot;
erfordern das Auswählen mehrerer Seedsongs.</p>
<div class="section" id="empfehlungsiteratoren">
<h3>4.2.1 Empfehlungsiteratoren<a class="headerlink" href="#empfehlungsiteratoren" title="Permalink to this headline">¶</a></h3>
<p>In allen Fällen wird jedoch von einem Seedsong aus eine Breitensuche gestartet.
Statt diese Breitensuche <em>sofort</em> auszuführen, wird jeweils nur ein Iterator
bereitgestellt welcher immer nur eine Empfehlung generiert und erst bei Zuruf
die nächste Empfehlung dynamisch generiert. Dieses, aus der funktionalen
Programmierung bekannte Konzept, ist sehr nützlich beim Filtern der generierten
Empfehlungen, denn man weiß im Vornherein nicht wieviele Empfehlungen
ausgefiltert werden. So kann der Iterator einfach so lange bemüht werden, bis
die gewünschte Anzahl an Empfehlungen generiert worden sind.</p>
<p>Sollten mehrere Seedsongs vorhanden sein, so wird einfach für jedem ein
Breitensuche&ndash;Iterator erstellt. Dieser liefert erst den Seedsong, dann den
besten Nachbarn, dann nächst schlechteren Nachbarn und später geht es mit den
indirekten Nachbarn weiter.  Diese Liste von Iteratoren wird dann im
Round&ndash;Robin&ndash;Verfahren ineinander <em>verwebt</em>. Dabei wird je der erste Iterator
in der Liste angestoßen, dann immer wieder der nächste um wieder am Anfang zu
beginnen.</p>
<p>Der daraus entstehende Iterator wird dann dem Nutzer der Bibliothek
bereitgestellt. Wird ein Element aus diesem obersten Iterator genommen, so hat
das ein <em>,,Nachrutschen&quot;</em> von Iteratoren zur Folge. Diese Hierarchie von
Iteratoren ist in  gezeigt.</p>
<div class="figure align-center" id="fig-iterator">
<a class="reference internal image-reference" href="../../_images/iterator.svg"><img alt="Traversierung durch verschachtelte Iteratoren" src="../../_images/iterator.svg" width="85%" /></a>
<p class="caption">Traversierung durch verschachtelte Iteratoren. Zieht der Nutzer einen Song
aus dem obersten Iterator, so löst das eine ,,Lawine” von Iterationsschritten
aus. Dabei werden die einzelnen Schritte ,,fair” via einem
Round&ndash;Robin&ndash;Verfahren auf die einzelnen Seed&ndash;Songs aufgeteilt.</p>
</div>
</div>
<div class="section" id="anwendung-von-regeln">
<span id="ref-graphops-rules"></span><h3>4.2.2 Anwendung von Regeln<a class="headerlink" href="#anwendung-von-regeln" title="Permalink to this headline">¶</a></h3>
<p>Die Assoziationsregeln die beim impliziten Lernen entstehen werden bei der
Traversierung als <em>,,Navigationshilfe&quot;</em> genutzt.</p>
<p>In  wird gezeigt, dass jedem Seedsong jeweils eine
Breitensuche und eine Menge von <em>Regeliteratoren</em> unterstellt sind.  <em>Libmunin</em>
bietet einen Mechanismus um alle Regeln abzufragen, die einen bestimmten Song
betreffen. Für jeden Song, der auf der <em>anderen</em> Seite der Regel vorkommt (also
die Seite, in der <em>nicht</em> der Seedsong vorhanden ist), wird ein
<em>Breitensucheniterator</em> erstellt.</p>
<p>Die einzelnen, den Regeln zugeordneten Iteratoren werden wieder im
Round&ndash;Robin&ndash;Verfahren abgewechselt. Der dadurch entstehende wird immer im
Wechsel mit dem <em>Breitensucheniterator</em>, der vom Seedsong ausgeht, abgefragt.
Daher besteht der Iterator, der aus einem Seedsong gebaut wird, wiederum aus
mehreren Unteriteratoren.</p>
</div>
<div class="section" id="filtern-der-iteratoren">
<h3>4.2.3 Filtern der Iteratoren<a class="headerlink" href="#filtern-der-iteratoren" title="Permalink to this headline">¶</a></h3>
<p>Da Alben im Graphen eng beieinander gepackt sind, werden ohne zusätzliches
Filtern natürlich auch Songs vom gleichen Album oder vom gleichen Künstler
geliefert. Dies ist für gewöhnlich nicht erwünscht &mdash; man möchte ja neue Musik
entdecken, die nicht immer vom selben Künstler kommt. Der optionale
Filterschritt (oder <em>Sieving</em>&ndash;Schritt) dient dazu diese unerwünschten Songs
herauszufiltern.</p>
<p>Um dieses Ziel zu erfüllen, werden alle Empfehlungen gespeichert, die von
<em>libmunin</em> ausgegeben werden. War der Künstler einer zu überprüfenden Empfehlung
in den, beispielsweise, fünf letzten Empfehlungen bereits vorhanden, so wird er
ausgesiebt. Ähnlich wird mit dem Album vorgegangen, nur hier ist die Schwelle
standardmäßig bei drei. Die einzelnen Schwellen können vom Nutzer konfiguriert
werden. <br />
Auch das <em>Sieving</em> ist als Iterator implementiert welcher Songs von einem
Empfehlungsiterator nimmt, aber nicht alle an den Nutzer weitergibt.</p>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../5_provider/index.html" class="btn btn-neutral float-right" title="5 Algorithmen bei Providern"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../3_einleitung/index.html" class="btn btn-neutral" title="3 Allgemeine Entwicklerhinweise"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright by Christopher Pahl, 2013-2014..
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>